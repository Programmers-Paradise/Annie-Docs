{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Annie.io \u00b6 Blazingly fast Approximate Nearest Neighbors in Rust Installation \u00b6 pip install rust_annie Basic Usage \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) Key Features \u00b6 Multiple distance metrics CPU/GPU acceleration Thread-safe indexes Filtered search HNSW support Navigation \u00b6 API Reference - Core classes and methods Examples - Usage examples and tutorials Concurrency - Thread-safe operations Filtering - Custom search filters Quick Links \u00b6 GitHub Repository PyPI Package Benchmark Results","title":"Home"},{"location":"#annieio","text":"Blazingly fast Approximate Nearest Neighbors in Rust","title":"Annie.io"},{"location":"#installation","text":"pip install rust_annie","title":"Installation"},{"location":"#basic-usage","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Basic Usage"},{"location":"#key-features","text":"Multiple distance metrics CPU/GPU acceleration Thread-safe indexes Filtered search HNSW support","title":"Key Features"},{"location":"#navigation","text":"API Reference - Core classes and methods Examples - Usage examples and tutorials Concurrency - Thread-safe operations Filtering - Custom search filters","title":"Navigation"},{"location":"#quick-links","text":"GitHub Repository PyPI Package Benchmark Results","title":"Quick Links"},{"location":"concurrency/","text":"Using ThreadSafeAnnIndex and PyHnswIndex for Concurrent Access \u00b6 Annie exposes a thread-safe version of its ANN index ( AnnIndex ) for use in Python. This is useful when you want to perform parallel search or update operations from Python threads. Additionally, the PyHnswIndex class provides a Python interface to the HNSW index, which now includes enhanced data handling capabilities. Key Features \u00b6 Safe concurrent read access ( search , search_batch ) Exclusive write access ( add , remove ) Backed by Rust RwLock and exposed via PyO3 PyHnswIndex supports mapping internal IDs to user IDs and handling vector data efficiently Example \u00b6 from annie import ThreadSafeAnnIndex, Distance import numpy as np import threading # Create index index = ThreadSafeAnnIndex(128, Distance.Cosine) # Add vectors data = np.random.rand(1000, 128).astype('float32') ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Run concurrent searches def run_search(): query = np.random.rand(128).astype('float32') ids, distances = index.search(query, 10) print(ids) threads = [threading.Thread(target=run_search) for _ in range(4)] [t.start() for t in threads] [t.join() for t in threads] # Using PyHnswIndex from rust_annie import PyHnswIndex # Create HNSW index hnsw_index = PyHnswIndex(dims=128) # Add vectors to HNSW index hnsw_index.add(data, ids) # Search in HNSW index query = np.random.rand(128).astype('float32') user_ids, distances = hnsw_index.search(query, 10) print(user_ids) CI/CD Pipeline for PyPI Publishing \u00b6 The CI/CD pipeline for PyPI publishing has been updated to include parallel jobs for building wheels and source distributions across multiple operating systems and Python versions. This involves concurrency considerations that should be documented for users who are integrating or maintaining the pipeline. Pipeline Overview \u00b6 The pipeline is triggered on pushes and pull requests to the main branch, as well as manually via workflow_dispatch . It includes the following jobs: Test : Runs on ubuntu-latest and includes steps for checking out the code, setting up Rust, caching dependencies, running tests, and checking code formatting. Build Wheels : Runs in parallel across ubuntu-latest , windows-latest , and macos-latest for Python versions 3.8, 3.9, 3.10, and 3.11. This job builds the wheels using maturin and uploads them as artifacts. Build Source Distribution : Runs on ubuntu-latest and builds the source distribution using maturin , uploading it as an artifact. Publish to TestPyPI : Publishes the built artifacts to TestPyPI if triggered via workflow_dispatch with the appropriate input. Publish to PyPI : Publishes the built artifacts to PyPI if triggered via workflow_dispatch with the appropriate input. Concurrency Considerations \u00b6 Parallel Builds : The build-wheels job utilizes a matrix strategy to run builds concurrently across different operating systems and Python versions. This reduces the overall build time but requires careful management of dependencies and environment setup to ensure consistency across platforms. Artifact Management : Artifacts from parallel jobs are downloaded and flattened before publishing to ensure all necessary files are available in a single directory structure for the publish steps. Conditional Publishing : Publishing steps are conditionally executed based on manual triggers and input parameters, allowing for flexible deployment strategies. By understanding these concurrency considerations, users can effectively manage and extend the CI/CD pipeline to suit their specific needs. AnnIndex - Brute-force Nearest Neighbor Search \u00b6 The AnnIndex class provides efficient brute-force nearest neighbor search with support for multiple distance metrics. Constructor \u00b6 AnnIndex(dim: int, metric: Distance) \u00b6 Creates a new brute-force index. dim (int): Vector dimension metric (Distance): Distance metric ( EUCLIDEAN , COSINE , MANHATTAN , CHEBYSHEV ) new_minkowski(dim: int, p: float) \u00b6 Creates a Minkowski distance index. dim (int): Vector dimension p (float): Minkowski exponent (p > 0) Methods \u00b6 add(data: ndarray, ids: ndarray) \u00b6 Add vectors to the index. data : N\u00d7dim array of float32 vectors ids : N-dimensional array of int64 IDs search(query: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Search for k nearest neighbors. query : dim-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances) search_batch(queries: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Batch search for multiple queries. queries : M\u00d7dim array of queries k : Number of neighbors per query Returns: (M\u00d7k IDs, M\u00d7k distances) search_filter_py(query: ndarray, k: int, filter_fn: Callable[[int], bool]) -> Tuple[ndarray, ndarray] \u00b6 Search with ID filtering. query : dim-dimensional query vector k : Maximum neighbors to return filter_fn : Function that returns True for allowed IDs Returns: (filtered IDs, filtered distances) save(path: str) \u00b6 Save index to disk. static load(path: str) -> AnnIndex \u00b6 Load index from disk. Example \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) PyHnswIndex - Approximate Nearest Neighbors with HNSW \u00b6 The PyHnswIndex class provides approximate nearest neighbor search using Hierarchical Navigable Small World (HNSW) graphs. Constructor \u00b6 PyHnswIndex(dims: int) \u00b6 Creates a new HNSW index. dims (int): Vector dimension Methods \u00b6 add(data: ndarray, ids: ndarray) \u00b6 Add vectors to the index. data : N\u00d7dims array of float32 vectors ids : N-dimensional array of int64 IDs search(vector: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Search for k approximate nearest neighbors. vector : dims-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances) save(path: str) \u00b6 Save index to disk. static load(path: str) -> PyHnswIndex \u00b6 Load index from disk (currently not implemented) Example \u00b6 import numpy as np from rust_annie import PyHnswIndex # Create index index = PyHnswIndex(dims=128) # Add data data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) ThreadSafeAnnIndex - Thread-safe Nearest Neighbor Index \u00b6 The ThreadSafeAnnIndex class provides a thread-safe wrapper around AnnIndex for concurrent access. Constructor \u00b6 ThreadSafeAnnIndex(dim: int, metric: Distance) \u00b6 Creates a new thread-safe index. dim (int): Vector dimension metric (Distance): Distance metric Methods \u00b6 add(data: ndarray, ids: ndarray) \u00b6 Thread-safe vector addition. remove(ids: List[int]) \u00b6 Thread-safe removal by IDs. search(query: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Thread-safe single query search. search_batch(queries: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Thread-safe batch search. save(path: str) \u00b6 Thread-safe save. static load(path: str) -> ThreadSafeAnnIndex \u00b6 Thread-safe load. Example \u00b6 import numpy as np from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor # Create index index = ThreadSafeAnnIndex(128, Distance.COSINE) # Add data from multiple threads with ThreadPoolExecutor() as executor: for i in range(4): data = np.random.rand(250, 128).astype(np.float32) ids = np.arange(i*250, (i+1)*250, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent searches with ThreadPoolExecutor() as executor: futures = [] for _ in range(10): query = np.random.rand(128).astype(np.float32) futures.append(executor.submit(index.search, query, k=5)) for future in futures: ids, dists = future.result() Annie Examples \u00b6 Basic Usage \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Generate and add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Single query query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) # Batch queries queries = np.random.rand(10, 128).astype(np.float32) batch_ids, batch_dists = index.search_batch(queries, k=3) Filtered Search \u00b6 # Create index with sample data index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Define filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids) # Only IDs 10 and 30 will be returned (20 is odd) HNSW Index \u00b6 from rust_annie import PyHnswIndex # Create HNSW index index = PyHnswIndex(dims=128) # Add large dataset data = np.random.rand(100000, 128).astype(np.float32) ids = np.arange(100000, dtype=np.int64) index.add(data, ids) # Fast approximate search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) Saving and Loading \u00b6 # Create and save index index = AnnIndex(64, Distance.COSINE) data = np.random.rand(500, 64).astype(np.float32) ids = np.arange(500, dtype=np.int64) index.add(data, ids) index.save(\"my_index\") # Load index loaded_index = AnnIndex.load(\"my_index\") Thread-safe Operations \u00b6 from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor index = ThreadSafeAnnIndex(256, Distance.MANHATTAN) # Concurrent writes with ThreadPoolExecutor() as executor: for i in range(10): data = np.random.rand(100, 256).astype(np.float32) ids = np.arange(i*100, (i+1)*100, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent reads with ThreadPoolExecutor() as executor: futures = [] for _ in range(100): query = np.random.rand(256).astype(np.float32) futures.append(executor.submit(index.search, query, k=3)) results = [f.result() for f in futures] Minkowski Distance \u00b6 # Create index with custom distance index = AnnIndex.new_minkowski(dim=64, p=2.5) data = np.random.rand(200, 64).astype(np.float32) ids = np.arange(200, dtype=np.int64) index.add(data, ids) # Search with Minkowski distance query = np.random.rand(64).astype(np.float32) ids, dists = index.search(query, k=5) Filtering \u00b6 Why Filtering? \u00b6 Filters allow you to narrow down search results dynamically based on: - Metadata (e.g., tags, IDs, labels) - Numeric thresholds (e.g., only items above/below a value) - Custom user-defined logic This improves both precision and flexibility of search. Example: Python API \u00b6 from rust_annie import AnnIndex import numpy as np # 1. Create an index with vector dimension 128 index = AnnIndex(dimension=128) # 2. Add data with metadata vector0 = np.random.rand(128).astype(np.float32) vector1 = np.random.rand(128).astype(np.float32) index.add_item(0, vector0, metadata={\"category\": \"A\"}) index.add_item(1, vector1, metadata={\"category\": \"B\"}) # 3. Define a filter function (e.g., only include items where category == \"A\") def category_filter(metadata): return metadata.get(\"category\") == \"A\" # 4. Perform search with the filter applied query_vector = np.random.rand(128).astype(np.float32) results = index.search(query_vector, k=5, filter=category_filter) print(\"Filtered search results:\", results) Supported Filters \u00b6 This library supports applying filters to narrow down ANN search results dynamically. Filter type Example Equals Filter.equals(\"category\", \"A\") Greater than Filter.gt(\"score\", 0.8) Less than Filter.lt(\"price\", 100) Custom predicate Filter.custom(lambda metadata: ...) Filters work on the metadata you provide when adding items to the index. Sorting Behavior \u00b6 The BruteForceIndex now uses total_cmp for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons. Benchmarking Indices \u00b6 The library now includes a benchmarking function to evaluate the performance of different index types, specifically PyHnswIndex and AnnIndex . This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type. Example: Benchmarking Script \u00b6 import numpy as np import time from rust_annie import PyHnswIndex, AnnIndex def benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10): print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\") # Data data = np.random.rand(n, dim).astype(np.float32) ids = np.arange(n, dtype=np.int64) queries = np.random.rand(q, dim).astype(np.float32) # Index setup index = index_cls(dims=dim) index.add(data, ids) # Warm-up + Timing times = [] for i in range(q): start = time.perf_counter() _ = index.search(queries[i], k=k) times.append((time.perf_counter() - start) * 1000) print(f\" Avg query time: {np.mean(times):.3f} ms\") print(f\" Max query time: {np.max(times):.3f} ms\") print(f\" Min query time: {np.min(times):.3f} ms\") if __name__ == \"__main__\": benchmark(PyHnswIndex, \"HNSW\") benchmark(AnnIndex, \"Brute-Force\") Integration & Extensibility \u00b6 Filters are exposed from Rust to Python via PyO3 bindings. New filters can be added by extending src/filters.rs in the Rust code. Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API. See also \u00b6 Example usage: scripts/filter_example.py Unit tests covering filter behavior: tests/test_filters.py Benchmarking script: scripts/compare.py Annie Documentation \u00b6 Blazingly fast Approximate Nearest Neighbors in Rust Installation \u00b6 pip install rust_annie Basic Usage \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) Key Features \u00b6 Multiple distance metrics CPU/GPU acceleration Thread-safe indexes Filtered search HNSW support","title":"Concurrency"},{"location":"concurrency/#using-threadsafeannindex-and-pyhnswindex-for-concurrent-access","text":"Annie exposes a thread-safe version of its ANN index ( AnnIndex ) for use in Python. This is useful when you want to perform parallel search or update operations from Python threads. Additionally, the PyHnswIndex class provides a Python interface to the HNSW index, which now includes enhanced data handling capabilities.","title":"Using ThreadSafeAnnIndex and PyHnswIndex for Concurrent Access"},{"location":"concurrency/#key-features","text":"Safe concurrent read access ( search , search_batch ) Exclusive write access ( add , remove ) Backed by Rust RwLock and exposed via PyO3 PyHnswIndex supports mapping internal IDs to user IDs and handling vector data efficiently","title":"Key Features"},{"location":"concurrency/#example","text":"from annie import ThreadSafeAnnIndex, Distance import numpy as np import threading # Create index index = ThreadSafeAnnIndex(128, Distance.Cosine) # Add vectors data = np.random.rand(1000, 128).astype('float32') ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Run concurrent searches def run_search(): query = np.random.rand(128).astype('float32') ids, distances = index.search(query, 10) print(ids) threads = [threading.Thread(target=run_search) for _ in range(4)] [t.start() for t in threads] [t.join() for t in threads] # Using PyHnswIndex from rust_annie import PyHnswIndex # Create HNSW index hnsw_index = PyHnswIndex(dims=128) # Add vectors to HNSW index hnsw_index.add(data, ids) # Search in HNSW index query = np.random.rand(128).astype('float32') user_ids, distances = hnsw_index.search(query, 10) print(user_ids)","title":"Example"},{"location":"concurrency/#cicd-pipeline-for-pypi-publishing","text":"The CI/CD pipeline for PyPI publishing has been updated to include parallel jobs for building wheels and source distributions across multiple operating systems and Python versions. This involves concurrency considerations that should be documented for users who are integrating or maintaining the pipeline.","title":"CI/CD Pipeline for PyPI Publishing"},{"location":"concurrency/#pipeline-overview","text":"The pipeline is triggered on pushes and pull requests to the main branch, as well as manually via workflow_dispatch . It includes the following jobs: Test : Runs on ubuntu-latest and includes steps for checking out the code, setting up Rust, caching dependencies, running tests, and checking code formatting. Build Wheels : Runs in parallel across ubuntu-latest , windows-latest , and macos-latest for Python versions 3.8, 3.9, 3.10, and 3.11. This job builds the wheels using maturin and uploads them as artifacts. Build Source Distribution : Runs on ubuntu-latest and builds the source distribution using maturin , uploading it as an artifact. Publish to TestPyPI : Publishes the built artifacts to TestPyPI if triggered via workflow_dispatch with the appropriate input. Publish to PyPI : Publishes the built artifacts to PyPI if triggered via workflow_dispatch with the appropriate input.","title":"Pipeline Overview"},{"location":"concurrency/#concurrency-considerations","text":"Parallel Builds : The build-wheels job utilizes a matrix strategy to run builds concurrently across different operating systems and Python versions. This reduces the overall build time but requires careful management of dependencies and environment setup to ensure consistency across platforms. Artifact Management : Artifacts from parallel jobs are downloaded and flattened before publishing to ensure all necessary files are available in a single directory structure for the publish steps. Conditional Publishing : Publishing steps are conditionally executed based on manual triggers and input parameters, allowing for flexible deployment strategies. By understanding these concurrency considerations, users can effectively manage and extend the CI/CD pipeline to suit their specific needs.","title":"Concurrency Considerations"},{"location":"concurrency/#annindex-brute-force-nearest-neighbor-search","text":"The AnnIndex class provides efficient brute-force nearest neighbor search with support for multiple distance metrics.","title":"AnnIndex - Brute-force Nearest Neighbor Search"},{"location":"concurrency/#constructor","text":"","title":"Constructor"},{"location":"concurrency/#annindexdim-int-metric-distance","text":"Creates a new brute-force index. dim (int): Vector dimension metric (Distance): Distance metric ( EUCLIDEAN , COSINE , MANHATTAN , CHEBYSHEV )","title":"AnnIndex(dim: int, metric: Distance)"},{"location":"concurrency/#new_minkowskidim-int-p-float","text":"Creates a Minkowski distance index. dim (int): Vector dimension p (float): Minkowski exponent (p > 0)","title":"new_minkowski(dim: int, p: float)"},{"location":"concurrency/#methods","text":"","title":"Methods"},{"location":"concurrency/#adddata-ndarray-ids-ndarray","text":"Add vectors to the index. data : N\u00d7dim array of float32 vectors ids : N-dimensional array of int64 IDs","title":"add(data: ndarray, ids: ndarray)"},{"location":"concurrency/#searchquery-ndarray-k-int-tuplendarray-ndarray","text":"Search for k nearest neighbors. query : dim-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances)","title":"search(query: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#search_batchqueries-ndarray-k-int-tuplendarray-ndarray","text":"Batch search for multiple queries. queries : M\u00d7dim array of queries k : Number of neighbors per query Returns: (M\u00d7k IDs, M\u00d7k distances)","title":"search_batch(queries: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#search_filter_pyquery-ndarray-k-int-filter_fn-callableint-bool-tuplendarray-ndarray","text":"Search with ID filtering. query : dim-dimensional query vector k : Maximum neighbors to return filter_fn : Function that returns True for allowed IDs Returns: (filtered IDs, filtered distances)","title":"search_filter_py(query: ndarray, k: int, filter_fn: Callable[[int], bool]) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#savepath-str","text":"Save index to disk.","title":"save(path: str)"},{"location":"concurrency/#static-loadpath-str-annindex","text":"Load index from disk.","title":"static load(path: str) -&gt; AnnIndex"},{"location":"concurrency/#example_1","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Example"},{"location":"concurrency/#pyhnswindex-approximate-nearest-neighbors-with-hnsw","text":"The PyHnswIndex class provides approximate nearest neighbor search using Hierarchical Navigable Small World (HNSW) graphs.","title":"PyHnswIndex - Approximate Nearest Neighbors with HNSW"},{"location":"concurrency/#constructor_1","text":"","title":"Constructor"},{"location":"concurrency/#pyhnswindexdims-int","text":"Creates a new HNSW index. dims (int): Vector dimension","title":"PyHnswIndex(dims: int)"},{"location":"concurrency/#methods_1","text":"","title":"Methods"},{"location":"concurrency/#adddata-ndarray-ids-ndarray_1","text":"Add vectors to the index. data : N\u00d7dims array of float32 vectors ids : N-dimensional array of int64 IDs","title":"add(data: ndarray, ids: ndarray)"},{"location":"concurrency/#searchvector-ndarray-k-int-tuplendarray-ndarray","text":"Search for k approximate nearest neighbors. vector : dims-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances)","title":"search(vector: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#savepath-str_1","text":"Save index to disk.","title":"save(path: str)"},{"location":"concurrency/#static-loadpath-str-pyhnswindex","text":"Load index from disk (currently not implemented)","title":"static load(path: str) -&gt; PyHnswIndex"},{"location":"concurrency/#example_2","text":"import numpy as np from rust_annie import PyHnswIndex # Create index index = PyHnswIndex(dims=128) # Add data data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"Example"},{"location":"concurrency/#threadsafeannindex-thread-safe-nearest-neighbor-index","text":"The ThreadSafeAnnIndex class provides a thread-safe wrapper around AnnIndex for concurrent access.","title":"ThreadSafeAnnIndex - Thread-safe Nearest Neighbor Index"},{"location":"concurrency/#constructor_2","text":"","title":"Constructor"},{"location":"concurrency/#threadsafeannindexdim-int-metric-distance","text":"Creates a new thread-safe index. dim (int): Vector dimension metric (Distance): Distance metric","title":"ThreadSafeAnnIndex(dim: int, metric: Distance)"},{"location":"concurrency/#methods_2","text":"","title":"Methods"},{"location":"concurrency/#adddata-ndarray-ids-ndarray_2","text":"Thread-safe vector addition.","title":"add(data: ndarray, ids: ndarray)"},{"location":"concurrency/#removeids-listint","text":"Thread-safe removal by IDs.","title":"remove(ids: List[int])"},{"location":"concurrency/#searchquery-ndarray-k-int-tuplendarray-ndarray_1","text":"Thread-safe single query search.","title":"search(query: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#search_batchqueries-ndarray-k-int-tuplendarray-ndarray_1","text":"Thread-safe batch search.","title":"search_batch(queries: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#savepath-str_2","text":"Thread-safe save.","title":"save(path: str)"},{"location":"concurrency/#static-loadpath-str-threadsafeannindex","text":"Thread-safe load.","title":"static load(path: str) -&gt; ThreadSafeAnnIndex"},{"location":"concurrency/#example_3","text":"import numpy as np from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor # Create index index = ThreadSafeAnnIndex(128, Distance.COSINE) # Add data from multiple threads with ThreadPoolExecutor() as executor: for i in range(4): data = np.random.rand(250, 128).astype(np.float32) ids = np.arange(i*250, (i+1)*250, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent searches with ThreadPoolExecutor() as executor: futures = [] for _ in range(10): query = np.random.rand(128).astype(np.float32) futures.append(executor.submit(index.search, query, k=5)) for future in futures: ids, dists = future.result()","title":"Example"},{"location":"concurrency/#annie-examples","text":"","title":"Annie Examples"},{"location":"concurrency/#basic-usage","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Generate and add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Single query query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) # Batch queries queries = np.random.rand(10, 128).astype(np.float32) batch_ids, batch_dists = index.search_batch(queries, k=3)","title":"Basic Usage"},{"location":"concurrency/#filtered-search","text":"# Create index with sample data index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Define filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids) # Only IDs 10 and 30 will be returned (20 is odd)","title":"Filtered Search"},{"location":"concurrency/#hnsw-index","text":"from rust_annie import PyHnswIndex # Create HNSW index index = PyHnswIndex(dims=128) # Add large dataset data = np.random.rand(100000, 128).astype(np.float32) ids = np.arange(100000, dtype=np.int64) index.add(data, ids) # Fast approximate search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"HNSW Index"},{"location":"concurrency/#saving-and-loading","text":"# Create and save index index = AnnIndex(64, Distance.COSINE) data = np.random.rand(500, 64).astype(np.float32) ids = np.arange(500, dtype=np.int64) index.add(data, ids) index.save(\"my_index\") # Load index loaded_index = AnnIndex.load(\"my_index\")","title":"Saving and Loading"},{"location":"concurrency/#thread-safe-operations","text":"from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor index = ThreadSafeAnnIndex(256, Distance.MANHATTAN) # Concurrent writes with ThreadPoolExecutor() as executor: for i in range(10): data = np.random.rand(100, 256).astype(np.float32) ids = np.arange(i*100, (i+1)*100, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent reads with ThreadPoolExecutor() as executor: futures = [] for _ in range(100): query = np.random.rand(256).astype(np.float32) futures.append(executor.submit(index.search, query, k=3)) results = [f.result() for f in futures]","title":"Thread-safe Operations"},{"location":"concurrency/#minkowski-distance","text":"# Create index with custom distance index = AnnIndex.new_minkowski(dim=64, p=2.5) data = np.random.rand(200, 64).astype(np.float32) ids = np.arange(200, dtype=np.int64) index.add(data, ids) # Search with Minkowski distance query = np.random.rand(64).astype(np.float32) ids, dists = index.search(query, k=5)","title":"Minkowski Distance"},{"location":"concurrency/#filtering","text":"","title":"Filtering"},{"location":"concurrency/#why-filtering","text":"Filters allow you to narrow down search results dynamically based on: - Metadata (e.g., tags, IDs, labels) - Numeric thresholds (e.g., only items above/below a value) - Custom user-defined logic This improves both precision and flexibility of search.","title":"Why Filtering?"},{"location":"concurrency/#example-python-api","text":"from rust_annie import AnnIndex import numpy as np # 1. Create an index with vector dimension 128 index = AnnIndex(dimension=128) # 2. Add data with metadata vector0 = np.random.rand(128).astype(np.float32) vector1 = np.random.rand(128).astype(np.float32) index.add_item(0, vector0, metadata={\"category\": \"A\"}) index.add_item(1, vector1, metadata={\"category\": \"B\"}) # 3. Define a filter function (e.g., only include items where category == \"A\") def category_filter(metadata): return metadata.get(\"category\") == \"A\" # 4. Perform search with the filter applied query_vector = np.random.rand(128).astype(np.float32) results = index.search(query_vector, k=5, filter=category_filter) print(\"Filtered search results:\", results)","title":"Example: Python API"},{"location":"concurrency/#supported-filters","text":"This library supports applying filters to narrow down ANN search results dynamically. Filter type Example Equals Filter.equals(\"category\", \"A\") Greater than Filter.gt(\"score\", 0.8) Less than Filter.lt(\"price\", 100) Custom predicate Filter.custom(lambda metadata: ...) Filters work on the metadata you provide when adding items to the index.","title":"Supported Filters"},{"location":"concurrency/#sorting-behavior","text":"The BruteForceIndex now uses total_cmp for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons.","title":"Sorting Behavior"},{"location":"concurrency/#benchmarking-indices","text":"The library now includes a benchmarking function to evaluate the performance of different index types, specifically PyHnswIndex and AnnIndex . This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type.","title":"Benchmarking Indices"},{"location":"concurrency/#example-benchmarking-script","text":"import numpy as np import time from rust_annie import PyHnswIndex, AnnIndex def benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10): print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\") # Data data = np.random.rand(n, dim).astype(np.float32) ids = np.arange(n, dtype=np.int64) queries = np.random.rand(q, dim).astype(np.float32) # Index setup index = index_cls(dims=dim) index.add(data, ids) # Warm-up + Timing times = [] for i in range(q): start = time.perf_counter() _ = index.search(queries[i], k=k) times.append((time.perf_counter() - start) * 1000) print(f\" Avg query time: {np.mean(times):.3f} ms\") print(f\" Max query time: {np.max(times):.3f} ms\") print(f\" Min query time: {np.min(times):.3f} ms\") if __name__ == \"__main__\": benchmark(PyHnswIndex, \"HNSW\") benchmark(AnnIndex, \"Brute-Force\")","title":"Example: Benchmarking Script"},{"location":"concurrency/#integration-extensibility","text":"Filters are exposed from Rust to Python via PyO3 bindings. New filters can be added by extending src/filters.rs in the Rust code. Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API.","title":"Integration &amp; Extensibility"},{"location":"concurrency/#see-also","text":"Example usage: scripts/filter_example.py Unit tests covering filter behavior: tests/test_filters.py Benchmarking script: scripts/compare.py","title":"See also"},{"location":"concurrency/#annie-documentation","text":"Blazingly fast Approximate Nearest Neighbors in Rust","title":"Annie Documentation"},{"location":"concurrency/#installation","text":"pip install rust_annie","title":"Installation"},{"location":"concurrency/#basic-usage_1","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Basic Usage"},{"location":"concurrency/#key-features_1","text":"Multiple distance metrics CPU/GPU acceleration Thread-safe indexes Filtered search HNSW support","title":"Key Features"},{"location":"contributing/","text":"Contributing to Annie Documentation \u00b6 Thank you for your interest in contributing to Annie's documentation! This guide will help you get started with contributing to our documentation site. \ud83d\udccb Table of Contents \u00b6 Getting Started Documentation Structure Setting Up Development Environment Making Changes Writing Guidelines Submitting Changes Review Process \ud83d\ude80 Getting Started \u00b6 Prerequisites \u00b6 Python 3.8+ Git Text editor or IDE Quick Setup \u00b6 Fork and Clone bash git clone https://github.com/YOUR-USERNAME/Annie-Docs.git cd Annie-Docs Build Documentation bash ./build-docs.sh Start Development Server bash source venv/bin/activate mkdocs serve Open in Browser Visit http://localhost:8000 to see your changes live. \ud83d\udcc1 Documentation Structure \u00b6 docs/ \u251c\u2500\u2500 index.md # Homepage \u251c\u2500\u2500 api/ # API Reference \u2502 \u251c\u2500\u2500 ann_index.md # AnnIndex class \u2502 \u251c\u2500\u2500 hnsw_index.md # PyHnswIndex class \u2502 \u2514\u2500\u2500 threadsafe_index.md \u251c\u2500\u2500 examples.md # Usage examples \u251c\u2500\u2500 concurrency.md # Thread-safety features \u2514\u2500\u2500 filtering.md # Filtered search \ud83d\udee0 Setting Up Development Environment \u00b6 Manual Setup \u00b6 # Create virtual environment python3 -m venv venv source venv/bin/activate # Install dependencies pip install -r requirements.txt # Build site mkdocs build # Serve locally with auto-reload mkdocs serve --dev-addr=0.0.0.0:8000 Using Scripts \u00b6 # Build documentation ./build-docs.sh # Deploy (build + prepare for hosting) ./deploy.sh \u270f\ufe0f Making Changes \u00b6 Types of Contributions \u00b6 Bug Fixes : Typos, broken links, formatting issues Content Updates : New examples, clarifications, additional details New Documentation : New features, API additions Structure Improvements : Navigation, organization, user experience Workflow \u00b6 Create a Branch bash git checkout -b feature/improve-examples Make Your Changes Edit files in the docs/ directory Use Markdown syntax Follow our writing guidelines Test Locally bash mkdocs serve Visit http://localhost:8000 to review changes Build and Verify bash mkdocs build Ensure no build errors \ud83d\udcdd Writing Guidelines \u00b6 Markdown Standards \u00b6 Use # for main headings, ## for sections, ### for subsections Use code blocks with language specification: python # Good import numpy as np Use **bold** for emphasis, *italic* for secondary emphasis Use backticks for inline code and class names like AnnIndex Code Examples \u00b6 Complete Examples : Show full working code Clear Comments : Explain what each section does Realistic Data : Use meaningful variable names and realistic scenarios Error Handling : Include error handling where appropriate # Good example import numpy as np from rust_annie import AnnIndex, Distance # Create index for 128-dimensional vectors index = AnnIndex(128, Distance.EUCLIDEAN) # Add sample data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search for nearest neighbors query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) print(f\"Found {len(neighbor_ids)} neighbors\") API Documentation \u00b6 Class Descriptions : Clear purpose and use cases Parameter Details : Type, description, constraints Return Values : What the method returns Examples : Show typical usage Error Conditions : When methods might fail Writing Style \u00b6 Clear and Concise : Get to the point quickly Beginner-Friendly : Explain concepts that might be unfamiliar Consistent Terminology : Use the same terms throughout Active Voice : \"Create an index\" vs \"An index is created\" \ud83d\udce4 Submitting Changes \u00b6 Before Submitting \u00b6 Test Your Changes bash mkdocs build # Check for build errors mkdocs serve # Test locally Check Links Ensure all internal links work Verify external links are accessible Review Content Proofread for typos and grammar Ensure code examples work Check formatting consistency Creating a Pull Request \u00b6 Commit Your Changes bash git add . git commit -m \"docs: improve examples in filtering.md\" Push to Your Fork bash git push origin feature/improve-examples Create Pull Request Go to GitHub and create a pull request Use a descriptive title Explain what you changed and why Reference any related issues Pull Request Template \u00b6 ## Description Brief description of changes made. ## Type of Change - [ ] Bug fix (typo, broken link, etc.) - [ ] Content update (new examples, clarifications) - [ ] New documentation (new features) - [ ] Structure improvement ## Testing - [ ] Built successfully with `mkdocs build` - [ ] Tested locally with `mkdocs serve` - [ ] Checked all links work - [ ] Verified code examples run ## Screenshots (if applicable) Add screenshots of significant visual changes. \ud83d\udd0d Review Process \u00b6 What We Look For \u00b6 Accuracy : Information is correct and up-to-date Clarity : Content is easy to understand Completeness : Examples work and are comprehensive Consistency : Follows existing style and structure Value : Genuinely helpful to users Review Timeline \u00b6 Initial Review : Within 2-3 days Feedback : We'll provide specific suggestions Approval : Once all feedback is addressed After Approval \u00b6 Changes are merged to main branch Documentation is automatically deployed Your contribution is credited \ud83c\udff7\ufe0f Issue Labels \u00b6 When creating issues, use these labels: documentation - General documentation issues bug - Errors in docs (typos, broken links) enhancement - Improvements to existing content new-content - Requests for new documentation good-first-issue - Good for newcomers \ud83d\udcac Getting Help \u00b6 GitHub Discussions : Ask questions about contributing Issues : Report bugs or request features Email : Contact maintainers directly \ud83c\udf89 Recognition \u00b6 Contributors are recognized in: - GitHub contributors list - Release notes for significant contributions - Special mentions for major improvements Thank you for helping make Annie's documentation better! \ud83d\ude80","title":"Contributing"},{"location":"contributing/#contributing-to-annie-documentation","text":"Thank you for your interest in contributing to Annie's documentation! This guide will help you get started with contributing to our documentation site.","title":"Contributing to Annie Documentation"},{"location":"contributing/#table-of-contents","text":"Getting Started Documentation Structure Setting Up Development Environment Making Changes Writing Guidelines Submitting Changes Review Process","title":"\ud83d\udccb Table of Contents"},{"location":"contributing/#getting-started","text":"","title":"\ud83d\ude80 Getting Started"},{"location":"contributing/#prerequisites","text":"Python 3.8+ Git Text editor or IDE","title":"Prerequisites"},{"location":"contributing/#quick-setup","text":"Fork and Clone bash git clone https://github.com/YOUR-USERNAME/Annie-Docs.git cd Annie-Docs Build Documentation bash ./build-docs.sh Start Development Server bash source venv/bin/activate mkdocs serve Open in Browser Visit http://localhost:8000 to see your changes live.","title":"Quick Setup"},{"location":"contributing/#documentation-structure","text":"docs/ \u251c\u2500\u2500 index.md # Homepage \u251c\u2500\u2500 api/ # API Reference \u2502 \u251c\u2500\u2500 ann_index.md # AnnIndex class \u2502 \u251c\u2500\u2500 hnsw_index.md # PyHnswIndex class \u2502 \u2514\u2500\u2500 threadsafe_index.md \u251c\u2500\u2500 examples.md # Usage examples \u251c\u2500\u2500 concurrency.md # Thread-safety features \u2514\u2500\u2500 filtering.md # Filtered search","title":"\ud83d\udcc1 Documentation Structure"},{"location":"contributing/#setting-up-development-environment","text":"","title":"\ud83d\udee0 Setting Up Development Environment"},{"location":"contributing/#manual-setup","text":"# Create virtual environment python3 -m venv venv source venv/bin/activate # Install dependencies pip install -r requirements.txt # Build site mkdocs build # Serve locally with auto-reload mkdocs serve --dev-addr=0.0.0.0:8000","title":"Manual Setup"},{"location":"contributing/#using-scripts","text":"# Build documentation ./build-docs.sh # Deploy (build + prepare for hosting) ./deploy.sh","title":"Using Scripts"},{"location":"contributing/#making-changes","text":"","title":"\u270f\ufe0f Making Changes"},{"location":"contributing/#types-of-contributions","text":"Bug Fixes : Typos, broken links, formatting issues Content Updates : New examples, clarifications, additional details New Documentation : New features, API additions Structure Improvements : Navigation, organization, user experience","title":"Types of Contributions"},{"location":"contributing/#workflow","text":"Create a Branch bash git checkout -b feature/improve-examples Make Your Changes Edit files in the docs/ directory Use Markdown syntax Follow our writing guidelines Test Locally bash mkdocs serve Visit http://localhost:8000 to review changes Build and Verify bash mkdocs build Ensure no build errors","title":"Workflow"},{"location":"contributing/#writing-guidelines","text":"","title":"\ud83d\udcdd Writing Guidelines"},{"location":"contributing/#markdown-standards","text":"Use # for main headings, ## for sections, ### for subsections Use code blocks with language specification: python # Good import numpy as np Use **bold** for emphasis, *italic* for secondary emphasis Use backticks for inline code and class names like AnnIndex","title":"Markdown Standards"},{"location":"contributing/#code-examples","text":"Complete Examples : Show full working code Clear Comments : Explain what each section does Realistic Data : Use meaningful variable names and realistic scenarios Error Handling : Include error handling where appropriate # Good example import numpy as np from rust_annie import AnnIndex, Distance # Create index for 128-dimensional vectors index = AnnIndex(128, Distance.EUCLIDEAN) # Add sample data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search for nearest neighbors query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) print(f\"Found {len(neighbor_ids)} neighbors\")","title":"Code Examples"},{"location":"contributing/#api-documentation","text":"Class Descriptions : Clear purpose and use cases Parameter Details : Type, description, constraints Return Values : What the method returns Examples : Show typical usage Error Conditions : When methods might fail","title":"API Documentation"},{"location":"contributing/#writing-style","text":"Clear and Concise : Get to the point quickly Beginner-Friendly : Explain concepts that might be unfamiliar Consistent Terminology : Use the same terms throughout Active Voice : \"Create an index\" vs \"An index is created\"","title":"Writing Style"},{"location":"contributing/#submitting-changes","text":"","title":"\ud83d\udce4 Submitting Changes"},{"location":"contributing/#before-submitting","text":"Test Your Changes bash mkdocs build # Check for build errors mkdocs serve # Test locally Check Links Ensure all internal links work Verify external links are accessible Review Content Proofread for typos and grammar Ensure code examples work Check formatting consistency","title":"Before Submitting"},{"location":"contributing/#creating-a-pull-request","text":"Commit Your Changes bash git add . git commit -m \"docs: improve examples in filtering.md\" Push to Your Fork bash git push origin feature/improve-examples Create Pull Request Go to GitHub and create a pull request Use a descriptive title Explain what you changed and why Reference any related issues","title":"Creating a Pull Request"},{"location":"contributing/#pull-request-template","text":"## Description Brief description of changes made. ## Type of Change - [ ] Bug fix (typo, broken link, etc.) - [ ] Content update (new examples, clarifications) - [ ] New documentation (new features) - [ ] Structure improvement ## Testing - [ ] Built successfully with `mkdocs build` - [ ] Tested locally with `mkdocs serve` - [ ] Checked all links work - [ ] Verified code examples run ## Screenshots (if applicable) Add screenshots of significant visual changes.","title":"Pull Request Template"},{"location":"contributing/#review-process","text":"","title":"\ud83d\udd0d Review Process"},{"location":"contributing/#what-we-look-for","text":"Accuracy : Information is correct and up-to-date Clarity : Content is easy to understand Completeness : Examples work and are comprehensive Consistency : Follows existing style and structure Value : Genuinely helpful to users","title":"What We Look For"},{"location":"contributing/#review-timeline","text":"Initial Review : Within 2-3 days Feedback : We'll provide specific suggestions Approval : Once all feedback is addressed","title":"Review Timeline"},{"location":"contributing/#after-approval","text":"Changes are merged to main branch Documentation is automatically deployed Your contribution is credited","title":"After Approval"},{"location":"contributing/#issue-labels","text":"When creating issues, use these labels: documentation - General documentation issues bug - Errors in docs (typos, broken links) enhancement - Improvements to existing content new-content - Requests for new documentation good-first-issue - Good for newcomers","title":"\ud83c\udff7\ufe0f Issue Labels"},{"location":"contributing/#getting-help","text":"GitHub Discussions : Ask questions about contributing Issues : Report bugs or request features Email : Contact maintainers directly","title":"\ud83d\udcac Getting Help"},{"location":"contributing/#recognition","text":"Contributors are recognized in: - GitHub contributors list - Release notes for significant contributions - Special mentions for major improvements Thank you for helping make Annie's documentation better! \ud83d\ude80","title":"\ud83c\udf89 Recognition"},{"location":"examples/","text":"Annie Examples \u00b6 Basic Usage \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Generate and add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Single query query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) # Batch queries queries = np.random.rand(10, 128).astype(np.float32) batch_ids, batch_dists = index.search_batch(queries, k=3) Filtered Search \u00b6 # Create index with sample data index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Define filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids) # Only IDs 10 and 30 will be returned (20 is odd) HNSW Index \u00b6 from rust_annie import PyHnswIndex # Create HNSW index index = PyHnswIndex(dims=128) # Add large dataset data = np.random.rand(100000, 128).astype(np.float32) ids = np.arange(100000, dtype=np.int64) index.add(data, ids) # Fast approximate search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) Saving and Loading \u00b6 # Create and save index index = AnnIndex(64, Distance.COSINE) data = np.random.rand(500, 64).astype(np.float32) ids = np.arange(500, dtype=np.int64) index.add(data, ids) index.save(\"my_index\") # Load index loaded_index = AnnIndex.load(\"my_index\") Thread-safe Operations \u00b6 from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor index = ThreadSafeAnnIndex(256, Distance.MANHATTAN) # Concurrent writes with ThreadPoolExecutor() as executor: for i in range(10): data = np.random.rand(100, 256).astype(np.float32) ids = np.arange(i*100, (i+1)*100, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent reads with ThreadPoolExecutor() as executor: futures = [] for _ in range(100): query = np.random.rand(256).astype(np.float32) futures.append(executor.submit(index.search, query, k=3)) results = [f.result() for f in futures] Minkowski Distance \u00b6 # Create index with custom distance index = AnnIndex.new_minkowski(dim=64, p=2.5) data = np.random.rand(200, 64).astype(np.float32) ids = np.arange(200, dtype=np.int64) index.add(data, ids) # Search with Minkowski distance query = np.random.rand(64).astype(np.float32) ids, dists = index.search(query, k=5) README \u00b6 A lightning-fast, Rust-powered Approximate Nearest Neighbor library for Python with multiple backends, thread-safety, and GPU acceleration. Table of Contents \u00b6 Features Installation Quick Start Examples Brute-Force Index HNSW Index Thread-Safe Index Benchmark Results API Reference Development & CI GPU Acceleration Documentation Contributing License Features \u00b6 Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking Installation \u00b6 # Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release Quick Start \u00b6 Brute-Force Index \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) HNSW Index \u00b6 from rust_annie import PyHnswIndex index = PyHnswIndex(dims=128) data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) Examples \u00b6 Brute-Force Index \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(4, Distance.COSINE) # Add data data = np.random.rand(50, 4).astype(np.float32) ids = np.arange(50, dtype=np.int64) idx.add(data, ids) # Search labels, dists = idx.search(data[10], k=3) print(labels, dists) Batch Query \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(16, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 16).astype(np.float32) ids = np.arange(1000, dtype=np.int64) idx.add(data, ids) # Batch search queries = data[:32] labels_batch, dists_batch = idx.search_batch(queries, k=10) print(labels_batch.shape) # (32, 10) Thread-Safe Index \u00b6 from rust_annie import ThreadSafeAnnIndex, Distance import numpy as np from concurrent.futures import ThreadPoolExecutor # Create thread-safe index idx = ThreadSafeAnnIndex(32, Distance.EUCLIDEAN) # Add data data = np.random.rand(500, 32).astype(np.float32) ids = np.arange(500, dtype=np.int64) idx.add(data, ids) # Concurrent searches def task(q): return idx.search(q, k=5) queries = np.random.rand(100, 32).astype(np.float32) with ThreadPoolExecutor(max_workers=8) as executor: futures = [executor.submit(task, q) for q in queries] for f in futures: print(f.result()) Filtered Search \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out) Build and Query a Brute-Force AnnIndex in Python (Complete Example) \u00b6 This section demonstrates a complete, beginner-friendly example of how to build and query a brute-force AnnIndex using Python. Measured on a 6-core CPU: That\u2019s a \\~4\u00d7 speedup vs. NumPy! Operation Dataset Size Time (ms) Speedup vs Python Single Query (Brute) 10,000 \u00d7 64 0.7 4\u00d7 Batch Query (64) 10,000 \u00d7 64 0.23 12\u00d7 HNSW Query 100,000 \u00d7 128 0.05 56\u00d7 View Full Benchmark Dashboard \u2192 \u00b6 You\u2019ll find: API Reference \u00b6 AnnIndex \u00b6 Create a brute-force k-NN index. Enum: Distance.EUCLIDEAN , Distance.COSINE , Distance.MANHATTAN ThreadSafeAnnIndex \u00b6 Same API as AnnIndex , safe for concurrent use. Core Classes \u00b6 Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc) Key Methods \u00b6 Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search save(path) Save index to disk load(path) Load index from disk Development & CI \u00b6 CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation Benchmark Automation \u00b6 Benchmarks are tracked over time using: GPU Acceleration \u00b6 Enable GPU in Rust \u00b6 Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed Contributing \u00b6 Contributions are welcome! Please: See CONTRIBUTING.md for details. License \u00b6 This project is licensed under the MIT License . See LICENSE for details.","title":"Examples"},{"location":"examples/#annie-examples","text":"","title":"Annie Examples"},{"location":"examples/#basic-usage","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Generate and add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Single query query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) # Batch queries queries = np.random.rand(10, 128).astype(np.float32) batch_ids, batch_dists = index.search_batch(queries, k=3)","title":"Basic Usage"},{"location":"examples/#filtered-search","text":"# Create index with sample data index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Define filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids) # Only IDs 10 and 30 will be returned (20 is odd)","title":"Filtered Search"},{"location":"examples/#hnsw-index","text":"from rust_annie import PyHnswIndex # Create HNSW index index = PyHnswIndex(dims=128) # Add large dataset data = np.random.rand(100000, 128).astype(np.float32) ids = np.arange(100000, dtype=np.int64) index.add(data, ids) # Fast approximate search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"HNSW Index"},{"location":"examples/#saving-and-loading","text":"# Create and save index index = AnnIndex(64, Distance.COSINE) data = np.random.rand(500, 64).astype(np.float32) ids = np.arange(500, dtype=np.int64) index.add(data, ids) index.save(\"my_index\") # Load index loaded_index = AnnIndex.load(\"my_index\")","title":"Saving and Loading"},{"location":"examples/#thread-safe-operations","text":"from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor index = ThreadSafeAnnIndex(256, Distance.MANHATTAN) # Concurrent writes with ThreadPoolExecutor() as executor: for i in range(10): data = np.random.rand(100, 256).astype(np.float32) ids = np.arange(i*100, (i+1)*100, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent reads with ThreadPoolExecutor() as executor: futures = [] for _ in range(100): query = np.random.rand(256).astype(np.float32) futures.append(executor.submit(index.search, query, k=3)) results = [f.result() for f in futures]","title":"Thread-safe Operations"},{"location":"examples/#minkowski-distance","text":"# Create index with custom distance index = AnnIndex.new_minkowski(dim=64, p=2.5) data = np.random.rand(200, 64).astype(np.float32) ids = np.arange(200, dtype=np.int64) index.add(data, ids) # Search with Minkowski distance query = np.random.rand(64).astype(np.float32) ids, dists = index.search(query, k=5)","title":"Minkowski Distance"},{"location":"examples/#readme","text":"A lightning-fast, Rust-powered Approximate Nearest Neighbor library for Python with multiple backends, thread-safety, and GPU acceleration.","title":"README"},{"location":"examples/#table-of-contents","text":"Features Installation Quick Start Examples Brute-Force Index HNSW Index Thread-Safe Index Benchmark Results API Reference Development & CI GPU Acceleration Documentation Contributing License","title":"Table of Contents"},{"location":"examples/#features","text":"Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking","title":"Features"},{"location":"examples/#installation","text":"# Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release","title":"Installation"},{"location":"examples/#quick-start","text":"","title":"Quick Start"},{"location":"examples/#brute-force-index","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Brute-Force Index"},{"location":"examples/#hnsw-index_1","text":"from rust_annie import PyHnswIndex index = PyHnswIndex(dims=128) data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"HNSW Index"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#brute-force-index_1","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(4, Distance.COSINE) # Add data data = np.random.rand(50, 4).astype(np.float32) ids = np.arange(50, dtype=np.int64) idx.add(data, ids) # Search labels, dists = idx.search(data[10], k=3) print(labels, dists)","title":"Brute-Force Index"},{"location":"examples/#batch-query","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(16, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 16).astype(np.float32) ids = np.arange(1000, dtype=np.int64) idx.add(data, ids) # Batch search queries = data[:32] labels_batch, dists_batch = idx.search_batch(queries, k=10) print(labels_batch.shape) # (32, 10)","title":"Batch Query"},{"location":"examples/#thread-safe-index","text":"from rust_annie import ThreadSafeAnnIndex, Distance import numpy as np from concurrent.futures import ThreadPoolExecutor # Create thread-safe index idx = ThreadSafeAnnIndex(32, Distance.EUCLIDEAN) # Add data data = np.random.rand(500, 32).astype(np.float32) ids = np.arange(500, dtype=np.int64) idx.add(data, ids) # Concurrent searches def task(q): return idx.search(q, k=5) queries = np.random.rand(100, 32).astype(np.float32) with ThreadPoolExecutor(max_workers=8) as executor: futures = [executor.submit(task, q) for q in queries] for f in futures: print(f.result())","title":"Thread-Safe Index"},{"location":"examples/#filtered-search_1","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out)","title":"Filtered Search"},{"location":"examples/#build-and-query-a-brute-force-annindex-in-python-complete-example","text":"This section demonstrates a complete, beginner-friendly example of how to build and query a brute-force AnnIndex using Python. Measured on a 6-core CPU: That\u2019s a \\~4\u00d7 speedup vs. NumPy! Operation Dataset Size Time (ms) Speedup vs Python Single Query (Brute) 10,000 \u00d7 64 0.7 4\u00d7 Batch Query (64) 10,000 \u00d7 64 0.23 12\u00d7 HNSW Query 100,000 \u00d7 128 0.05 56\u00d7","title":"Build and Query a Brute-Force AnnIndex in Python (Complete Example)"},{"location":"examples/#view-full-benchmark-dashboard","text":"You\u2019ll find:","title":"View Full Benchmark Dashboard \u2192"},{"location":"examples/#api-reference","text":"","title":"API Reference"},{"location":"examples/#annindex","text":"Create a brute-force k-NN index. Enum: Distance.EUCLIDEAN , Distance.COSINE , Distance.MANHATTAN","title":"AnnIndex"},{"location":"examples/#threadsafeannindex","text":"Same API as AnnIndex , safe for concurrent use.","title":"ThreadSafeAnnIndex"},{"location":"examples/#core-classes","text":"Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc)","title":"Core Classes"},{"location":"examples/#key-methods","text":"Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search save(path) Save index to disk load(path) Load index from disk","title":"Key Methods"},{"location":"examples/#development-ci","text":"CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation","title":"Development &amp; CI"},{"location":"examples/#benchmark-automation","text":"Benchmarks are tracked over time using:","title":"Benchmark Automation"},{"location":"examples/#gpu-acceleration","text":"","title":"GPU Acceleration"},{"location":"examples/#enable-gpu-in-rust","text":"Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed","title":"Enable GPU in Rust"},{"location":"examples/#contributing","text":"Contributions are welcome! Please: See CONTRIBUTING.md for details.","title":"Contributing"},{"location":"examples/#license","text":"This project is licensed under the MIT License . See LICENSE for details.","title":"License"},{"location":"filtering/","text":"## ANN Search Filtering This document explains how to use the filtering capabilities to improve Approximate Nearest Neighbor (ANN) search. ### Why Filtering? Filters allow you to narrow down search results dynamically based on: - Metadata (e.g., tags, IDs, labels) - Numeric thresholds (e.g., only items above/below a value) - Custom user-defined logic This improves both precision and flexibility of search. #### Example: Python API ```python from rust_annie import AnnIndex import numpy as np # 1. Create an index with vector dimension 128 index = AnnIndex(dimension=128) # 2. Add data with metadata vector0 = np.random.rand(128).astype(np.float32) vector1 = np.random.rand(128).astype(np.float32) index.add_item(0, vector0, metadata={\"category\": \"A\"}) index.add_item(1, vector1, metadata={\"category\": \"B\"}) # 3. Define a filter function (e.g., only include items where category == \"A\") def category_filter(metadata): return metadata.get(\"category\") == \"A\" # 4. Perform search with the filter applied query_vector = np.random.rand(128).astype(np.float32) results = index.search(query_vector, k=5, filter=category_filter) print(\"Filtered search results:\", results) Supported Filters \u00b6 This library supports applying filters to narrow down ANN search results dynamically. Filter type Example Equals Filter.equals(\"category\", \"A\") Greater than Filter.gt(\"score\", 0.8) Less than Filter.lt(\"price\", 100) Custom predicate Filter.custom(lambda metadata: ...) Filters work on the metadata you provide when adding items to the index. New Feature: Filtered Search with Custom Python Callbacks \u00b6 The library now supports filtered search using custom Python callbacks, allowing for more complex filtering logic directly in Python. Example: Filtered Search with Python Callback \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out) Sorting Behavior \u00b6 The BruteForceIndex now uses total_cmp for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons. Benchmarking Indices \u00b6 The library now includes a benchmarking function to evaluate the performance of different index types, specifically PyHnswIndex and AnnIndex . This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type. Example: Benchmarking Script \u00b6 import numpy as np import time from rust_annie import PyHnswIndex, AnnIndex def benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10): print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\") # Data data = np.random.rand(n, dim).astype(np.float32) ids = np.arange(n, dtype=np.int64) queries = np.random.rand(q, dim).astype(np.float32) # Index setup index = index_cls(dims=dim) index.add(data, ids) # Warm-up + Timing times = [] for i in range(q): start = time.perf_counter() _ = index.search(queries[i], k=k) times.append((time.perf_counter() - start) * 1000) print(f\" Avg query time: {np.mean(times):.3f} ms\") print(f\" Max query time: {np.max(times):.3f} ms\") print(f\" Min query time: {np.min(times):.3f} ms\") if __name__ == \"__main__\": benchmark(PyHnswIndex, \"HNSW\") benchmark(AnnIndex, \"Brute-Force\") Integration & Extensibility \u00b6 Filters are exposed from Rust to Python via PyO3 bindings. New filters can be added by extending src/filters.rs in the Rust code. Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API. See also \u00b6 Example usage: scripts/filter_example.py Unit tests covering filter behavior: tests/test_filters.py Benchmarking script: scripts/compare.py ```","title":"Filtered Search"},{"location":"filtering/#supported-filters","text":"This library supports applying filters to narrow down ANN search results dynamically. Filter type Example Equals Filter.equals(\"category\", \"A\") Greater than Filter.gt(\"score\", 0.8) Less than Filter.lt(\"price\", 100) Custom predicate Filter.custom(lambda metadata: ...) Filters work on the metadata you provide when adding items to the index.","title":"Supported Filters"},{"location":"filtering/#new-feature-filtered-search-with-custom-python-callbacks","text":"The library now supports filtered search using custom Python callbacks, allowing for more complex filtering logic directly in Python.","title":"New Feature: Filtered Search with Custom Python Callbacks"},{"location":"filtering/#example-filtered-search-with-python-callback","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out)","title":"Example: Filtered Search with Python Callback"},{"location":"filtering/#sorting-behavior","text":"The BruteForceIndex now uses total_cmp for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons.","title":"Sorting Behavior"},{"location":"filtering/#benchmarking-indices","text":"The library now includes a benchmarking function to evaluate the performance of different index types, specifically PyHnswIndex and AnnIndex . This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type.","title":"Benchmarking Indices"},{"location":"filtering/#example-benchmarking-script","text":"import numpy as np import time from rust_annie import PyHnswIndex, AnnIndex def benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10): print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\") # Data data = np.random.rand(n, dim).astype(np.float32) ids = np.arange(n, dtype=np.int64) queries = np.random.rand(q, dim).astype(np.float32) # Index setup index = index_cls(dims=dim) index.add(data, ids) # Warm-up + Timing times = [] for i in range(q): start = time.perf_counter() _ = index.search(queries[i], k=k) times.append((time.perf_counter() - start) * 1000) print(f\" Avg query time: {np.mean(times):.3f} ms\") print(f\" Max query time: {np.max(times):.3f} ms\") print(f\" Min query time: {np.min(times):.3f} ms\") if __name__ == \"__main__\": benchmark(PyHnswIndex, \"HNSW\") benchmark(AnnIndex, \"Brute-Force\")","title":"Example: Benchmarking Script"},{"location":"filtering/#integration-extensibility","text":"Filters are exposed from Rust to Python via PyO3 bindings. New filters can be added by extending src/filters.rs in the Rust code. Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API.","title":"Integration &amp; Extensibility"},{"location":"filtering/#see-also","text":"Example usage: scripts/filter_example.py Unit tests covering filter behavior: tests/test_filters.py Benchmarking script: scripts/compare.py ```","title":"See also"},{"location":"hosting/","text":"\ud83c\udf10 Hosting Guide \u00b6 This guide covers multiple ways to make your Annie documentation site publicly accessible. \ud83d\ude80 Quick Public Access (Local Network) \u00b6 Option 1: Network Access \u00b6 Share your documentation with others on the same network: ./serve-public.sh This makes your site accessible at: - Local : http://localhost:8000 - Network : http://YOUR-IP:8000 (shareable with others on your network) Option 2: Temporary Public URL \u00b6 Create a temporary public URL using ngrok: # Install ngrok first (see instructions in script) ./tunnel.sh This creates a temporary public URL like https://abc123.ngrok.io \ud83c\udfe0 Free Hosting Services \u00b6 GitHub Pages (Recommended) \u00b6 Automatic deployment - Push to trigger deployment: Enable GitHub Pages : Go to repository Settings \u2192 Pages Source: \"GitHub Actions\" Push changes : bash git add . git commit -m \"docs: update documentation\" git push origin main Access : https://YOUR-USERNAME.github.io/Annie-Docs/ \u2705 Pros : Free, automatic builds, custom domains \u274c Cons : GitHub dependency, public repos only (free tier) Netlify \u00b6 One-click deployment : Connect Repository : Go to netlify.com \"New site from Git\" \u2192 Connect your GitHub repo Deploy Settings (auto-detected via netlify.toml ): Build command: pip install -r requirements.txt && mkdocs build Publish directory: site Custom Domain (optional): Add custom domain in Netlify dashboard Annie-docs.netlify.app \u2192 your-domain.com \u2705 Pros : Easy setup, instant deploys, branch previews, forms \u274c Cons : Build minutes limit (free tier) Vercel \u00b6 Deployment via CLI or Dashboard : Install Vercel CLI : bash npm install -g vercel Deploy : bash vercel Or via Dashboard : Import GitHub repo at vercel.com Configuration auto-detected via vercel.json \u2705 Pros : Fast edge network, great performance, preview deployments \u274c Cons : Node.js focused (but works with Python) \ud83d\udcbb Self-Hosting \u00b6 Simple HTTP Server \u00b6 # Build site mkdocs build # Serve on custom port cd site python3 -m http.server 80 # Requires sudo for port 80 # Or with nginx sudo apt install nginx sudo cp -r site/* /var/www/html/ Docker Container \u00b6 Create Dockerfile : FROM python:3.11-slim WORKDIR /app COPY requirements.txt . RUN pip install -r requirements.txt COPY . . RUN mkdocs build FROM nginx:alpine COPY --from=0 /app/site /usr/share/nginx/html EXPOSE 80 Build and run: docker build -t annie-docs . docker run -p 80:80 annie-docs \u2601\ufe0f Cloud Hosting \u00b6 AWS S3 + CloudFront \u00b6 # Build site mkdocs build # Upload to S3 aws s3 sync site/ s3://your-bucket-name --delete # Configure S3 for static hosting aws s3 website s3://your-bucket-name --index-document index.html Google Cloud Storage \u00b6 # Build and upload mkdocs build gsutil -m cp -r site/* gs://your-bucket-name/ # Enable website configuration gsutil web set -m index.html -e 404.html gs://your-bucket-name \ud83d\udee1\ufe0f Security & Performance \u00b6 HTTPS Configuration \u00b6 Free SSL Certificates : - Let's Encrypt : Free SSL for custom domains - Cloudflare : Free tier includes SSL - GitHub Pages : Automatic HTTPS - Netlify/Vercel : Free SSL included Performance Optimization \u00b6 Content Delivery Network (CDN) : - Cloudflare : Free tier available - AWS CloudFront : Pay-per-use - Netlify/Vercel : CDN included Optimization tips : # Minify during build (add to mkdocs.yml) plugins: - minify: minify_html: true minify_css: true minify_js: true \ud83d\udcca Monitoring & Analytics \u00b6 Google Analytics \u00b6 Add to mkdocs.yml : google_analytics: - 'UA-XXXXXXXX-X' - 'auto' Simple Analytics \u00b6 <!-- Add to custom theme --> <script async defer src=\"https://scripts.simpleanalyticscdn.com/latest.js\"></script> \ud83d\udd27 Continuous Deployment \u00b6 GitHub Actions (Included) \u00b6 The .github/workflows/deploy-docs.yml automatically: 1. Builds documentation on every push 2. Deploys to GitHub Pages 3. Updates live site within minutes Webhook Deployment \u00b6 For custom servers, create a webhook endpoint: # webhook.php <?php if ($_POST['secret'] === 'your-secret') { exec('cd /path/to/docs && git pull && mkdocs build'); } ?> \ud83d\udcf1 Mobile Optimization \u00b6 The ReadTheDocs theme is mobile-responsive, but test on: - \ud83d\udcf1 Mobile phones (320px+) - \ud83d\udcf1 Tablets (768px+) - \ud83d\udcbb Desktop (1024px+) \ud83d\udd0d SEO Optimization \u00b6 Add to mkdocs.yml : site_name: Annie Documentation site_description: Blazingly fast Approximate Nearest Neighbors in Rust site_url: https://your-domain.com extra: social: - icon: fontawesome/brands/github link: https://github.com/Programmers-Paradise/Annie - icon: fontawesome/brands/python link: https://pypi.org/project/rust-annie/ \u2753 Troubleshooting \u00b6 Common Issues \u00b6 Build Fails : # Check Python version python --version # Should be 3.8+ # Reinstall dependencies rm -rf venv ./build-docs.sh 404 Errors : - Check mkdocs.yml navigation paths - Verify file names match exactly - Ensure case sensitivity Slow Loading : - Enable gzip compression - Use CDN - Optimize images - Minify CSS/JS Getting Help \u00b6 \ud83d\udc1b Report issues \ud83d\udcac Ask questions \ud83d\udce7 Contact maintainers Choose the hosting option that best fits your needs: - \ud83c\udfe0 Local/Testing : ./serve-public.sh - \ud83c\udf10 Temporary Public : ./tunnel.sh - \ud83c\udd93 Free Hosting : GitHub Pages, Netlify, Vercel - \ud83d\udcbc Professional : AWS, Google Cloud, self-hosted","title":"Hosting Guide"},{"location":"hosting/#hosting-guide","text":"This guide covers multiple ways to make your Annie documentation site publicly accessible.","title":"\ud83c\udf10 Hosting Guide"},{"location":"hosting/#quick-public-access-local-network","text":"","title":"\ud83d\ude80 Quick Public Access (Local Network)"},{"location":"hosting/#option-1-network-access","text":"Share your documentation with others on the same network: ./serve-public.sh This makes your site accessible at: - Local : http://localhost:8000 - Network : http://YOUR-IP:8000 (shareable with others on your network)","title":"Option 1: Network Access"},{"location":"hosting/#option-2-temporary-public-url","text":"Create a temporary public URL using ngrok: # Install ngrok first (see instructions in script) ./tunnel.sh This creates a temporary public URL like https://abc123.ngrok.io","title":"Option 2: Temporary Public URL"},{"location":"hosting/#free-hosting-services","text":"","title":"\ud83c\udfe0 Free Hosting Services"},{"location":"hosting/#github-pages-recommended","text":"Automatic deployment - Push to trigger deployment: Enable GitHub Pages : Go to repository Settings \u2192 Pages Source: \"GitHub Actions\" Push changes : bash git add . git commit -m \"docs: update documentation\" git push origin main Access : https://YOUR-USERNAME.github.io/Annie-Docs/ \u2705 Pros : Free, automatic builds, custom domains \u274c Cons : GitHub dependency, public repos only (free tier)","title":"GitHub Pages (Recommended)"},{"location":"hosting/#netlify","text":"One-click deployment : Connect Repository : Go to netlify.com \"New site from Git\" \u2192 Connect your GitHub repo Deploy Settings (auto-detected via netlify.toml ): Build command: pip install -r requirements.txt && mkdocs build Publish directory: site Custom Domain (optional): Add custom domain in Netlify dashboard Annie-docs.netlify.app \u2192 your-domain.com \u2705 Pros : Easy setup, instant deploys, branch previews, forms \u274c Cons : Build minutes limit (free tier)","title":"Netlify"},{"location":"hosting/#vercel","text":"Deployment via CLI or Dashboard : Install Vercel CLI : bash npm install -g vercel Deploy : bash vercel Or via Dashboard : Import GitHub repo at vercel.com Configuration auto-detected via vercel.json \u2705 Pros : Fast edge network, great performance, preview deployments \u274c Cons : Node.js focused (but works with Python)","title":"Vercel"},{"location":"hosting/#self-hosting","text":"","title":"\ud83d\udcbb Self-Hosting"},{"location":"hosting/#simple-http-server","text":"# Build site mkdocs build # Serve on custom port cd site python3 -m http.server 80 # Requires sudo for port 80 # Or with nginx sudo apt install nginx sudo cp -r site/* /var/www/html/","title":"Simple HTTP Server"},{"location":"hosting/#docker-container","text":"Create Dockerfile : FROM python:3.11-slim WORKDIR /app COPY requirements.txt . RUN pip install -r requirements.txt COPY . . RUN mkdocs build FROM nginx:alpine COPY --from=0 /app/site /usr/share/nginx/html EXPOSE 80 Build and run: docker build -t annie-docs . docker run -p 80:80 annie-docs","title":"Docker Container"},{"location":"hosting/#cloud-hosting","text":"","title":"\u2601\ufe0f Cloud Hosting"},{"location":"hosting/#aws-s3-cloudfront","text":"# Build site mkdocs build # Upload to S3 aws s3 sync site/ s3://your-bucket-name --delete # Configure S3 for static hosting aws s3 website s3://your-bucket-name --index-document index.html","title":"AWS S3 + CloudFront"},{"location":"hosting/#google-cloud-storage","text":"# Build and upload mkdocs build gsutil -m cp -r site/* gs://your-bucket-name/ # Enable website configuration gsutil web set -m index.html -e 404.html gs://your-bucket-name","title":"Google Cloud Storage"},{"location":"hosting/#security-performance","text":"","title":"\ud83d\udee1\ufe0f Security &amp; Performance"},{"location":"hosting/#https-configuration","text":"Free SSL Certificates : - Let's Encrypt : Free SSL for custom domains - Cloudflare : Free tier includes SSL - GitHub Pages : Automatic HTTPS - Netlify/Vercel : Free SSL included","title":"HTTPS Configuration"},{"location":"hosting/#performance-optimization","text":"Content Delivery Network (CDN) : - Cloudflare : Free tier available - AWS CloudFront : Pay-per-use - Netlify/Vercel : CDN included Optimization tips : # Minify during build (add to mkdocs.yml) plugins: - minify: minify_html: true minify_css: true minify_js: true","title":"Performance Optimization"},{"location":"hosting/#monitoring-analytics","text":"","title":"\ud83d\udcca Monitoring &amp; Analytics"},{"location":"hosting/#google-analytics","text":"Add to mkdocs.yml : google_analytics: - 'UA-XXXXXXXX-X' - 'auto'","title":"Google Analytics"},{"location":"hosting/#simple-analytics","text":"<!-- Add to custom theme --> <script async defer src=\"https://scripts.simpleanalyticscdn.com/latest.js\"></script>","title":"Simple Analytics"},{"location":"hosting/#continuous-deployment","text":"","title":"\ud83d\udd27 Continuous Deployment"},{"location":"hosting/#github-actions-included","text":"The .github/workflows/deploy-docs.yml automatically: 1. Builds documentation on every push 2. Deploys to GitHub Pages 3. Updates live site within minutes","title":"GitHub Actions (Included)"},{"location":"hosting/#webhook-deployment","text":"For custom servers, create a webhook endpoint: # webhook.php <?php if ($_POST['secret'] === 'your-secret') { exec('cd /path/to/docs && git pull && mkdocs build'); } ?>","title":"Webhook Deployment"},{"location":"hosting/#mobile-optimization","text":"The ReadTheDocs theme is mobile-responsive, but test on: - \ud83d\udcf1 Mobile phones (320px+) - \ud83d\udcf1 Tablets (768px+) - \ud83d\udcbb Desktop (1024px+)","title":"\ud83d\udcf1 Mobile Optimization"},{"location":"hosting/#seo-optimization","text":"Add to mkdocs.yml : site_name: Annie Documentation site_description: Blazingly fast Approximate Nearest Neighbors in Rust site_url: https://your-domain.com extra: social: - icon: fontawesome/brands/github link: https://github.com/Programmers-Paradise/Annie - icon: fontawesome/brands/python link: https://pypi.org/project/rust-annie/","title":"\ud83d\udd0d SEO Optimization"},{"location":"hosting/#troubleshooting","text":"","title":"\u2753 Troubleshooting"},{"location":"hosting/#common-issues","text":"Build Fails : # Check Python version python --version # Should be 3.8+ # Reinstall dependencies rm -rf venv ./build-docs.sh 404 Errors : - Check mkdocs.yml navigation paths - Verify file names match exactly - Ensure case sensitivity Slow Loading : - Enable gzip compression - Use CDN - Optimize images - Minify CSS/JS","title":"Common Issues"},{"location":"hosting/#getting-help","text":"\ud83d\udc1b Report issues \ud83d\udcac Ask questions \ud83d\udce7 Contact maintainers Choose the hosting option that best fits your needs: - \ud83c\udfe0 Local/Testing : ./serve-public.sh - \ud83c\udf10 Temporary Public : ./tunnel.sh - \ud83c\udd93 Free Hosting : GitHub Pages, Netlify, Vercel - \ud83d\udcbc Professional : AWS, Google Cloud, self-hosted","title":"Getting Help"},{"location":"api/ann_index/","text":"AnnIndex - Brute-force Nearest Neighbor Search \u00b6 The AnnIndex class provides efficient brute-force nearest neighbor search with support for multiple distance metrics and additional features like filtered search. Constructor \u00b6 AnnIndex(dim: int, metric: Distance) \u00b6 Creates a new brute-force index. dim (int): Vector dimension metric (Distance): Distance metric ( EUCLIDEAN , COSINE , MANHATTAN , CHEBYSHEV ) new_minkowski(dim: int, p: float) \u00b6 Creates a Minkowski distance index. dim (int): Vector dimension p (float): Minkowski exponent (p > 0) Methods \u00b6 add(data: ndarray, ids: ndarray) \u00b6 Add vectors to the index. data : N\u00d7dim array of float32 vectors ids : N-dimensional array of int64 IDs search(query: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Search for k nearest neighbors. query : dim-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances) search_batch(queries: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Batch search for multiple queries. queries : M\u00d7dim array of queries k : Number of neighbors per query Returns: (M\u00d7k IDs, M\u00d7k distances) search_filter_py(query: ndarray, k: int, filter_fn: Callable[[int], bool]) -> Tuple[ndarray, ndarray] \u00b6 Search with ID filtering. query : dim-dimensional query vector k : Maximum neighbors to return filter_fn : Function that returns True for allowed IDs Returns: (filtered IDs, filtered distances) len() -> int \u00b6 Get the number of entries in the index. Returns: Number of entries in the index dim() -> int \u00b6 Get the dimension of vectors in the index. Returns: Dimension of vectors save(path: str) \u00b6 Save index to disk. static load(path: str) -> AnnIndex \u00b6 Load index from disk. Example \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Check index properties print(\"Number of entries:\", index.len()) print(\"Dimension of vectors:\", index.dim()) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) Features \u00b6 Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking Installation \u00b6 # Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release Quick Start \u00b6 Brute-Force Index \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Check index properties print(\"Number of entries:\", index.len()) print(\"Dimension of vectors:\", index.dim()) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) HNSW Index \u00b6 from rust_annie import PyHnswIndex index = PyHnswIndex(dims=128) data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) Examples \u00b6 Brute-Force Index \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(4, Distance.COSINE) # Add data data = np.random.rand(50, 4).astype(np.float32) ids = np.arange(50, dtype=np.int64) idx.add(data, ids) # Check index properties print(\"Number of entries:\", idx.len()) print(\"Dimension of vectors:\", idx.dim()) # Search labels, dists = idx.search(data[10], k=3) print(labels, dists) Batch Query \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(16, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 16).astype(np.float32) ids = np.arange(1000, dtype=np.int64) idx.add(data, ids) # Check index properties print(\"Number of entries:\", idx.len()) print(\"Dimension of vectors:\", idx.dim()) # Batch search queries = data[:32] labels_batch, dists_batch = idx.search_batch(queries, k=10) print(labels_batch.shape) # (32, 10) Thread-Safe Index \u00b6 from rust_annie import ThreadSafeAnnIndex, Distance import numpy as np from concurrent.futures import ThreadPoolExecutor # Create thread-safe index idx = ThreadSafeAnnIndex(32, Distance.EUCLIDEAN) # Add data data = np.random.rand(500, 32).astype(np.float32) ids = np.arange(500, dtype=np.int64) idx.add(data, ids) # Check index properties print(\"Number of entries:\", idx.len()) print(\"Dimension of vectors:\", idx.dim()) # Concurrent searches def task(q): return idx.search(q, k=5) queries = data[:10] with ThreadPoolExecutor(max_workers=8) as executor: results = executor.map(task, queries) for f in results: print(f) Filtered Search \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Check index properties print(\"Number of entries:\", index.len()) print(\"Dimension of vectors:\", index.dim()) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out) Build and Query a Brute-Force AnnIndex in Python (Complete Example) \u00b6 This section demonstrates a complete, beginner-friendly example of how to build and query a brute-force AnnIndex using Python. Benchmark Results \u00b6 Measured on a 6-core CPU: That\u2019s a \\~4\u00d7 speedup vs. NumPy! Operation Dataset Size Time (ms) Speedup vs Python Single Query (Brute) 10,000 \u00d7 64 0.7 4\u00d7 Batch Query (64) 10,000 \u00d7 64 0.23 12\u00d7 HNSW Query 100,000 \u00d7 128 0.05 56\u00d7 View Full Benchmark Dashboard \u2192 \u00b6 You\u2019ll find: API Reference \u00b6 Core Classes \u00b6 Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc) Key Methods \u00b6 Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search len() Get the number of entries in the index dim() Get the dimension of vectors in the index save(path) Save index to disk load(path) Load index from disk Development & CI \u00b6 CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation Benchmark Automation \u00b6 Benchmarks are tracked over time using: GPU Acceleration \u00b6 Enable GPU in Rust \u00b6 Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed Contributing \u00b6 Contributions are welcome! Please: See CONTRIBUTING.md for details. License \u00b6 This project is licensed under the MIT License . See LICENSE for details.","title":"AnnIndex"},{"location":"api/ann_index/#annindex-brute-force-nearest-neighbor-search","text":"The AnnIndex class provides efficient brute-force nearest neighbor search with support for multiple distance metrics and additional features like filtered search.","title":"AnnIndex - Brute-force Nearest Neighbor Search"},{"location":"api/ann_index/#constructor","text":"","title":"Constructor"},{"location":"api/ann_index/#annindexdim-int-metric-distance","text":"Creates a new brute-force index. dim (int): Vector dimension metric (Distance): Distance metric ( EUCLIDEAN , COSINE , MANHATTAN , CHEBYSHEV )","title":"AnnIndex(dim: int, metric: Distance)"},{"location":"api/ann_index/#new_minkowskidim-int-p-float","text":"Creates a Minkowski distance index. dim (int): Vector dimension p (float): Minkowski exponent (p > 0)","title":"new_minkowski(dim: int, p: float)"},{"location":"api/ann_index/#methods","text":"","title":"Methods"},{"location":"api/ann_index/#adddata-ndarray-ids-ndarray","text":"Add vectors to the index. data : N\u00d7dim array of float32 vectors ids : N-dimensional array of int64 IDs","title":"add(data: ndarray, ids: ndarray)"},{"location":"api/ann_index/#searchquery-ndarray-k-int-tuplendarray-ndarray","text":"Search for k nearest neighbors. query : dim-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances)","title":"search(query: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"api/ann_index/#search_batchqueries-ndarray-k-int-tuplendarray-ndarray","text":"Batch search for multiple queries. queries : M\u00d7dim array of queries k : Number of neighbors per query Returns: (M\u00d7k IDs, M\u00d7k distances)","title":"search_batch(queries: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"api/ann_index/#search_filter_pyquery-ndarray-k-int-filter_fn-callableint-bool-tuplendarray-ndarray","text":"Search with ID filtering. query : dim-dimensional query vector k : Maximum neighbors to return filter_fn : Function that returns True for allowed IDs Returns: (filtered IDs, filtered distances)","title":"search_filter_py(query: ndarray, k: int, filter_fn: Callable[[int], bool]) -&gt; Tuple[ndarray, ndarray]"},{"location":"api/ann_index/#len-int","text":"Get the number of entries in the index. Returns: Number of entries in the index","title":"len() -&gt; int"},{"location":"api/ann_index/#dim-int","text":"Get the dimension of vectors in the index. Returns: Dimension of vectors","title":"dim() -&gt; int"},{"location":"api/ann_index/#savepath-str","text":"Save index to disk.","title":"save(path: str)"},{"location":"api/ann_index/#static-loadpath-str-annindex","text":"Load index from disk.","title":"static load(path: str) -&gt; AnnIndex"},{"location":"api/ann_index/#example","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Check index properties print(\"Number of entries:\", index.len()) print(\"Dimension of vectors:\", index.dim()) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Example"},{"location":"api/ann_index/#features","text":"Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking","title":"Features"},{"location":"api/ann_index/#installation","text":"# Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release","title":"Installation"},{"location":"api/ann_index/#quick-start","text":"","title":"Quick Start"},{"location":"api/ann_index/#brute-force-index","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Check index properties print(\"Number of entries:\", index.len()) print(\"Dimension of vectors:\", index.dim()) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Brute-Force Index"},{"location":"api/ann_index/#hnsw-index","text":"from rust_annie import PyHnswIndex index = PyHnswIndex(dims=128) data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"HNSW Index"},{"location":"api/ann_index/#examples","text":"","title":"Examples"},{"location":"api/ann_index/#brute-force-index_1","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(4, Distance.COSINE) # Add data data = np.random.rand(50, 4).astype(np.float32) ids = np.arange(50, dtype=np.int64) idx.add(data, ids) # Check index properties print(\"Number of entries:\", idx.len()) print(\"Dimension of vectors:\", idx.dim()) # Search labels, dists = idx.search(data[10], k=3) print(labels, dists)","title":"Brute-Force Index"},{"location":"api/ann_index/#batch-query","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(16, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 16).astype(np.float32) ids = np.arange(1000, dtype=np.int64) idx.add(data, ids) # Check index properties print(\"Number of entries:\", idx.len()) print(\"Dimension of vectors:\", idx.dim()) # Batch search queries = data[:32] labels_batch, dists_batch = idx.search_batch(queries, k=10) print(labels_batch.shape) # (32, 10)","title":"Batch Query"},{"location":"api/ann_index/#thread-safe-index","text":"from rust_annie import ThreadSafeAnnIndex, Distance import numpy as np from concurrent.futures import ThreadPoolExecutor # Create thread-safe index idx = ThreadSafeAnnIndex(32, Distance.EUCLIDEAN) # Add data data = np.random.rand(500, 32).astype(np.float32) ids = np.arange(500, dtype=np.int64) idx.add(data, ids) # Check index properties print(\"Number of entries:\", idx.len()) print(\"Dimension of vectors:\", idx.dim()) # Concurrent searches def task(q): return idx.search(q, k=5) queries = data[:10] with ThreadPoolExecutor(max_workers=8) as executor: results = executor.map(task, queries) for f in results: print(f)","title":"Thread-Safe Index"},{"location":"api/ann_index/#filtered-search","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Check index properties print(\"Number of entries:\", index.len()) print(\"Dimension of vectors:\", index.dim()) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out)","title":"Filtered Search"},{"location":"api/ann_index/#build-and-query-a-brute-force-annindex-in-python-complete-example","text":"This section demonstrates a complete, beginner-friendly example of how to build and query a brute-force AnnIndex using Python.","title":"Build and Query a Brute-Force AnnIndex in Python (Complete Example)"},{"location":"api/ann_index/#benchmark-results","text":"Measured on a 6-core CPU: That\u2019s a \\~4\u00d7 speedup vs. NumPy! Operation Dataset Size Time (ms) Speedup vs Python Single Query (Brute) 10,000 \u00d7 64 0.7 4\u00d7 Batch Query (64) 10,000 \u00d7 64 0.23 12\u00d7 HNSW Query 100,000 \u00d7 128 0.05 56\u00d7","title":"Benchmark Results"},{"location":"api/ann_index/#view-full-benchmark-dashboard","text":"You\u2019ll find:","title":"View Full Benchmark Dashboard \u2192"},{"location":"api/ann_index/#api-reference","text":"","title":"API Reference"},{"location":"api/ann_index/#core-classes","text":"Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc)","title":"Core Classes"},{"location":"api/ann_index/#key-methods","text":"Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search len() Get the number of entries in the index dim() Get the dimension of vectors in the index save(path) Save index to disk load(path) Load index from disk","title":"Key Methods"},{"location":"api/ann_index/#development-ci","text":"CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation","title":"Development &amp; CI"},{"location":"api/ann_index/#benchmark-automation","text":"Benchmarks are tracked over time using:","title":"Benchmark Automation"},{"location":"api/ann_index/#gpu-acceleration","text":"","title":"GPU Acceleration"},{"location":"api/ann_index/#enable-gpu-in-rust","text":"Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed","title":"Enable GPU in Rust"},{"location":"api/ann_index/#contributing","text":"Contributions are welcome! Please: See CONTRIBUTING.md for details.","title":"Contributing"},{"location":"api/ann_index/#license","text":"This project is licensed under the MIT License . See LICENSE for details.","title":"License"},{"location":"api/hnsw_index/","text":"# PyHnswIndex - Approximate Nearest Neighbors with HNSW The `PyHnswIndex` class provides approximate nearest neighbor search using Hierarchical Navigable Small World (HNSW) graphs. ## Constructor ### `PyHnswIndex(dims: int)` Creates a new HNSW index. - `dims` (int): Vector dimension ## Methods ### `add(data: ndarray, ids: ndarray)` Add vectors to the index. - `data`: N\u00d7dims array of float32 vectors - `ids`: N-dimensional array of int64 IDs ### `search(vector: ndarray, k: int) -> Tuple[ndarray, ndarray]` Search for k approximate nearest neighbors. - `vector`: dims-dimensional query vector - `k`: Number of neighbors to return - Returns: (neighbor IDs, distances) ### `save(path: str)` Save index to disk. ### `static load(path: str) -> PyHnswIndex` Load index from disk (currently not implemented) ## Example ```python import numpy as np from rust_annie import PyHnswIndex # Create index index = PyHnswIndex(dims=128) # Add data data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) A lightning-fast, Rust-powered Approximate Nearest Neighbor library for Python with multiple backends, thread-safety, and GPU acceleration. Table of Contents \u00b6 Features Installation Quick Start Examples Brute-Force Index HNSW Index Thread-Safe Index Benchmark Results API Reference Development & CI GPU Acceleration Documentation Contributing License Features \u00b6 Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking Installation \u00b6 # Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release Quick Start \u00b6 Brute-Force Index \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) HNSW Index \u00b6 from rust_annie import PyHnswIndex index = PyHnswIndex(dims=128) data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) Examples \u00b6 Brute-Force Index \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(4, Distance.COSINE) # Add data data = np.random.rand(50, 4).astype(np.float32) ids = np.arange(50, dtype=np.int64) idx.add(data, ids) # Search labels, dists = idx.search(data[10], k=3) print(labels, dists) Batch Query \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(16, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 16).astype(np.float32) ids = np.arange(1000, dtype=np.int64) idx.add(data, ids) # Batch search queries = data[:32] labels_batch, dists_batch = idx.search_batch(queries, k=10) print(labels_batch.shape) # (32, 10) Thread-Safe Index \u00b6 from rust_annie import ThreadSafeAnnIndex, Distance import numpy as np from concurrent.futures import ThreadPoolExecutor # Create thread-safe index idx = ThreadSafeAnnIndex(32, Distance.EUCLIDEAN) # Add data data = np.random.rand(500, 32).astype(np.float32) ids = np.arange(500, dtype=np.int64) idx.add(data, ids) # Concurrent searches def task(q): return idx.search(q, k=5) with ThreadPoolExecutor(max_workers=8) as executor: futures = [executor.submit(task, data[i]) for i in range(10)] for f in futures: print(f.result()) Filtered Search \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out) Build and Query a Brute-Force AnnIndex in Python (Complete Example) \u00b6 This section demonstrates a complete, beginner-friendly example of how to build and query a brute-force AnnIndex using Python. Measured on a 6-core CPU: That\u2019s a \\~4\u00d7 speedup vs. NumPy! Operation Dataset Size Time (ms) Speedup vs Python Single Query (Brute) 10,000 \u00d7 64 0.7 4\u00d7 Batch Query (64) 10,000 \u00d7 64 0.23 12\u00d7 HNSW Query 100,000 \u00d7 128 0.05 56\u00d7 View Full Benchmark Dashboard \u2192 \u00b6 You\u2019ll find: API Reference \u00b6 AnnIndex \u00b6 Constructor : AnnIndex(dims: int, distance: Distance) Methods : add , search , search_batch , save , load Distance Metrics : Enum: Distance.EUCLIDEAN , Distance.COSINE , Distance.MANHATTAN ThreadSafeAnnIndex \u00b6 Same API as AnnIndex , safe for concurrent use. Core Classes \u00b6 Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc) Key Methods \u00b6 Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search save(path) Save index to disk load(path) Load index from disk Development & CI \u00b6 CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation Benchmark Automation \u00b6 Benchmarks are tracked over time using: GPU Acceleration \u00b6 CUDA Support \u00b6 Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed ROCm (AMD GPU) support is not yet available. Enable GPU in Rust \u00b6 Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Contributing \u00b6 Contributions are welcome! Please: Fork the repository Create a feature branch Submit a pull request See CONTRIBUTING.md for details. License \u00b6 This project is licensed under the MIT License . See LICENSE for details. ```","title":"PyHnswIndex"},{"location":"api/hnsw_index/#table-of-contents","text":"Features Installation Quick Start Examples Brute-Force Index HNSW Index Thread-Safe Index Benchmark Results API Reference Development & CI GPU Acceleration Documentation Contributing License","title":"Table of Contents"},{"location":"api/hnsw_index/#features","text":"Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking","title":"Features"},{"location":"api/hnsw_index/#installation","text":"# Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release","title":"Installation"},{"location":"api/hnsw_index/#quick-start","text":"","title":"Quick Start"},{"location":"api/hnsw_index/#brute-force-index","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Brute-Force Index"},{"location":"api/hnsw_index/#hnsw-index","text":"from rust_annie import PyHnswIndex index = PyHnswIndex(dims=128) data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"HNSW Index"},{"location":"api/hnsw_index/#examples","text":"","title":"Examples"},{"location":"api/hnsw_index/#brute-force-index_1","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(4, Distance.COSINE) # Add data data = np.random.rand(50, 4).astype(np.float32) ids = np.arange(50, dtype=np.int64) idx.add(data, ids) # Search labels, dists = idx.search(data[10], k=3) print(labels, dists)","title":"Brute-Force Index"},{"location":"api/hnsw_index/#batch-query","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(16, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 16).astype(np.float32) ids = np.arange(1000, dtype=np.int64) idx.add(data, ids) # Batch search queries = data[:32] labels_batch, dists_batch = idx.search_batch(queries, k=10) print(labels_batch.shape) # (32, 10)","title":"Batch Query"},{"location":"api/hnsw_index/#thread-safe-index","text":"from rust_annie import ThreadSafeAnnIndex, Distance import numpy as np from concurrent.futures import ThreadPoolExecutor # Create thread-safe index idx = ThreadSafeAnnIndex(32, Distance.EUCLIDEAN) # Add data data = np.random.rand(500, 32).astype(np.float32) ids = np.arange(500, dtype=np.int64) idx.add(data, ids) # Concurrent searches def task(q): return idx.search(q, k=5) with ThreadPoolExecutor(max_workers=8) as executor: futures = [executor.submit(task, data[i]) for i in range(10)] for f in futures: print(f.result())","title":"Thread-Safe Index"},{"location":"api/hnsw_index/#filtered-search","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out)","title":"Filtered Search"},{"location":"api/hnsw_index/#build-and-query-a-brute-force-annindex-in-python-complete-example","text":"This section demonstrates a complete, beginner-friendly example of how to build and query a brute-force AnnIndex using Python. Measured on a 6-core CPU: That\u2019s a \\~4\u00d7 speedup vs. NumPy! Operation Dataset Size Time (ms) Speedup vs Python Single Query (Brute) 10,000 \u00d7 64 0.7 4\u00d7 Batch Query (64) 10,000 \u00d7 64 0.23 12\u00d7 HNSW Query 100,000 \u00d7 128 0.05 56\u00d7","title":"Build and Query a Brute-Force AnnIndex in Python (Complete Example)"},{"location":"api/hnsw_index/#view-full-benchmark-dashboard","text":"You\u2019ll find:","title":"View Full Benchmark Dashboard \u2192"},{"location":"api/hnsw_index/#api-reference","text":"","title":"API Reference"},{"location":"api/hnsw_index/#annindex","text":"Constructor : AnnIndex(dims: int, distance: Distance) Methods : add , search , search_batch , save , load Distance Metrics : Enum: Distance.EUCLIDEAN , Distance.COSINE , Distance.MANHATTAN","title":"AnnIndex"},{"location":"api/hnsw_index/#threadsafeannindex","text":"Same API as AnnIndex , safe for concurrent use.","title":"ThreadSafeAnnIndex"},{"location":"api/hnsw_index/#core-classes","text":"Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc)","title":"Core Classes"},{"location":"api/hnsw_index/#key-methods","text":"Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search save(path) Save index to disk load(path) Load index from disk","title":"Key Methods"},{"location":"api/hnsw_index/#development-ci","text":"CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation","title":"Development &amp; CI"},{"location":"api/hnsw_index/#benchmark-automation","text":"Benchmarks are tracked over time using:","title":"Benchmark Automation"},{"location":"api/hnsw_index/#gpu-acceleration","text":"","title":"GPU Acceleration"},{"location":"api/hnsw_index/#cuda-support","text":"Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed ROCm (AMD GPU) support is not yet available.","title":"CUDA Support"},{"location":"api/hnsw_index/#enable-gpu-in-rust","text":"Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu","title":"Enable GPU in Rust"},{"location":"api/hnsw_index/#contributing","text":"Contributions are welcome! Please: Fork the repository Create a feature branch Submit a pull request See CONTRIBUTING.md for details.","title":"Contributing"},{"location":"api/hnsw_index/#license","text":"This project is licensed under the MIT License . See LICENSE for details. ```","title":"License"},{"location":"api/threadsafe_index/","text":"ThreadSafeAnnIndex - Thread-safe Nearest Neighbor Index \u00b6 The ThreadSafeAnnIndex class provides a thread-safe wrapper around AnnIndex for concurrent access. Constructor \u00b6 ThreadSafeAnnIndex(dim: int, metric: Distance) \u00b6 Creates a new thread-safe index. dim (int): Vector dimension metric (Distance): Distance metric Methods \u00b6 add(data: ndarray, ids: ndarray) \u00b6 Thread-safe vector addition. remove(ids: List[int]) \u00b6 Thread-safe removal by IDs. search(query: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Thread-safe single query search. search_batch(queries: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Thread-safe batch search. search_filter_py(query: ndarray, k: int, filter_fn: Callable[[int], bool]) -> Tuple[ndarray, ndarray] \u00b6 Thread-safe filtered search using a custom Python callback function. save(path: str) \u00b6 Thread-safe save. static load(path: str) -> ThreadSafeAnnIndex \u00b6 Thread-safe load. Example \u00b6 import numpy as np from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor # Create index index = ThreadSafeAnnIndex(128, Distance.COSINE) # Add data from multiple threads with ThreadPoolExecutor() as executor: for i in range(4): data = np.random.rand(250, 128).astype(np.float32) ids = np.arange(i*250, (i+1)*250, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent searches with ThreadPoolExecutor() as executor: futures = [] for _ in range(10): query = np.random.rand(128).astype(np.float32) futures.append(executor.submit(index.search, query, k=5)) for future in futures: ids, dists = future.result() # Filtered search def even_ids(id: int) -> bool: return id % 2 == 0 query = np.random.rand(128).astype(np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=5, filter_fn=even_ids) print(filtered_ids) Core Classes \u00b6 Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc) Key Methods \u00b6 Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search save(path) Save index to disk load(path) Load index from disk Development & CI \u00b6 CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation Benchmark Automation \u00b6 Benchmarks are tracked over time using: Continuous integration with performance tracking Automated scripts for consistent benchmarking GPU Acceleration \u00b6 Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed Contributing \u00b6 Contributions are welcome! Please: Fork the repository Create a feature branch Submit a pull request See CONTRIBUTING.md for details. License \u00b6 This project is licensed under the MIT License . See LICENSE for details.","title":"ThreadSafeAnnIndex"},{"location":"api/threadsafe_index/#threadsafeannindex-thread-safe-nearest-neighbor-index","text":"The ThreadSafeAnnIndex class provides a thread-safe wrapper around AnnIndex for concurrent access.","title":"ThreadSafeAnnIndex - Thread-safe Nearest Neighbor Index"},{"location":"api/threadsafe_index/#constructor","text":"","title":"Constructor"},{"location":"api/threadsafe_index/#threadsafeannindexdim-int-metric-distance","text":"Creates a new thread-safe index. dim (int): Vector dimension metric (Distance): Distance metric","title":"ThreadSafeAnnIndex(dim: int, metric: Distance)"},{"location":"api/threadsafe_index/#methods","text":"","title":"Methods"},{"location":"api/threadsafe_index/#adddata-ndarray-ids-ndarray","text":"Thread-safe vector addition.","title":"add(data: ndarray, ids: ndarray)"},{"location":"api/threadsafe_index/#removeids-listint","text":"Thread-safe removal by IDs.","title":"remove(ids: List[int])"},{"location":"api/threadsafe_index/#searchquery-ndarray-k-int-tuplendarray-ndarray","text":"Thread-safe single query search.","title":"search(query: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"api/threadsafe_index/#search_batchqueries-ndarray-k-int-tuplendarray-ndarray","text":"Thread-safe batch search.","title":"search_batch(queries: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"api/threadsafe_index/#search_filter_pyquery-ndarray-k-int-filter_fn-callableint-bool-tuplendarray-ndarray","text":"Thread-safe filtered search using a custom Python callback function.","title":"search_filter_py(query: ndarray, k: int, filter_fn: Callable[[int], bool]) -&gt; Tuple[ndarray, ndarray]"},{"location":"api/threadsafe_index/#savepath-str","text":"Thread-safe save.","title":"save(path: str)"},{"location":"api/threadsafe_index/#static-loadpath-str-threadsafeannindex","text":"Thread-safe load.","title":"static load(path: str) -&gt; ThreadSafeAnnIndex"},{"location":"api/threadsafe_index/#example","text":"import numpy as np from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor # Create index index = ThreadSafeAnnIndex(128, Distance.COSINE) # Add data from multiple threads with ThreadPoolExecutor() as executor: for i in range(4): data = np.random.rand(250, 128).astype(np.float32) ids = np.arange(i*250, (i+1)*250, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent searches with ThreadPoolExecutor() as executor: futures = [] for _ in range(10): query = np.random.rand(128).astype(np.float32) futures.append(executor.submit(index.search, query, k=5)) for future in futures: ids, dists = future.result() # Filtered search def even_ids(id: int) -> bool: return id % 2 == 0 query = np.random.rand(128).astype(np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=5, filter_fn=even_ids) print(filtered_ids)","title":"Example"},{"location":"api/threadsafe_index/#core-classes","text":"Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc)","title":"Core Classes"},{"location":"api/threadsafe_index/#key-methods","text":"Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search save(path) Save index to disk load(path) Load index from disk","title":"Key Methods"},{"location":"api/threadsafe_index/#development-ci","text":"CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation","title":"Development &amp; CI"},{"location":"api/threadsafe_index/#benchmark-automation","text":"Benchmarks are tracked over time using: Continuous integration with performance tracking Automated scripts for consistent benchmarking","title":"Benchmark Automation"},{"location":"api/threadsafe_index/#gpu-acceleration","text":"Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed","title":"GPU Acceleration"},{"location":"api/threadsafe_index/#contributing","text":"Contributions are welcome! Please: Fork the repository Create a feature branch Submit a pull request See CONTRIBUTING.md for details.","title":"Contributing"},{"location":"api/threadsafe_index/#license","text":"This project is licensed under the MIT License . See LICENSE for details.","title":"License"}]}