{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Annie.io \u00b6 Blazingly fast Approximate Nearest Neighbors in Rust Installation \u00b6 # Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release Basic Usage \u00b6 Brute-Force Index \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) Key Features \u00b6 Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking Navigation \u00b6 API Reference - Core classes and methods Examples - Usage examples and tutorials Concurrency - Thread-safe operations Filtering - Custom search filters Quick Links \u00b6 GitHub Repository PyPI Package Benchmark Results","title":"Home"},{"location":"#annieio","text":"Blazingly fast Approximate Nearest Neighbors in Rust","title":"Annie.io"},{"location":"#installation","text":"# Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release","title":"Installation"},{"location":"#basic-usage","text":"","title":"Basic Usage"},{"location":"#brute-force-index","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Brute-Force Index"},{"location":"#key-features","text":"Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking","title":"Key Features"},{"location":"#navigation","text":"API Reference - Core classes and methods Examples - Usage examples and tutorials Concurrency - Thread-safe operations Filtering - Custom search filters","title":"Navigation"},{"location":"#quick-links","text":"GitHub Repository PyPI Package Benchmark Results","title":"Quick Links"},{"location":"concurrency/","text":"Using ThreadSafeAnnIndex and PyHnswIndex for Concurrent Access \u00b6 Annie exposes a thread-safe version of its ANN index ( AnnIndex ) for use in Python. This is useful when you want to perform parallel search or update operations from Python threads. Additionally, the PyHnswIndex class provides a Python interface to the HNSW index, which now includes enhanced data handling capabilities. Key Features \u00b6 Safe concurrent read access ( search , search_batch ) Exclusive write access ( add , remove ) Backed by Rust RwLock and exposed via PyO3 PyHnswIndex supports mapping internal IDs to user IDs and handling vector data efficiently Example \u00b6 from annie import ThreadSafeAnnIndex, Distance import numpy as np import threading # Create index index = ThreadSafeAnnIndex(128, Distance.Cosine) # Add vectors data = np.random.rand(1000, 128).astype('float32') ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Run concurrent searches def run_search(): query = np.random.rand(128).astype('float32') ids, distances = index.search(query, 10) print(ids) threads = [threading.Thread(target=run_search) for _ in range(4)] [t.start() for t in threads] [t.join() for t in threads] # Using PyHnswIndex from rust_annie import PyHnswIndex # Create HNSW index hnsw_index = PyHnswIndex(dims=128) # Add vectors to HNSW index hnsw_index.add(data, ids) # Search in HNSW index query = np.random.rand(128).astype('float32') user_ids, distances = hnsw_index.search(query, 10) print(user_ids) CI/CD Pipeline for PyPI Publishing \u00b6 The CI/CD pipeline for PyPI publishing has been updated to include parallel jobs for building wheels and source distributions across multiple operating systems and Python versions. This involves concurrency considerations that should be documented for users who are integrating or maintaining the pipeline. Pipeline Overview \u00b6 The pipeline is triggered on pushes and pull requests to the main branch, as well as manually via workflow_dispatch . It includes the following jobs: Test : Runs on ubuntu-latest and includes steps for checking out the code, setting up Rust, caching dependencies, running tests, and checking code formatting. Build Wheels : Runs in parallel across ubuntu-latest , windows-latest , and macos-latest for Python versions 3.8, 3.9, 3.10, and 3.11. This job builds the wheels using maturin and uploads them as artifacts. Build Source Distribution : Runs on ubuntu-latest and builds the source distribution using maturin , uploading it as an artifact. Publish to TestPyPI : Publishes the built artifacts to TestPyPI if triggered via workflow_dispatch with the appropriate input. Publish to PyPI : Publishes the built artifacts to PyPI if triggered via workflow_dispatch with the appropriate input. Concurrency Considerations \u00b6 Parallel Builds : The build-wheels job utilizes a matrix strategy to run builds concurrently across different operating systems and Python versions. This reduces the overall build time but requires careful management of dependencies and environment setup to ensure consistency across platforms. Artifact Management : Artifacts from parallel jobs are downloaded and flattened before publishing to ensure all necessary files are available in a single directory structure for the publish steps. Conditional Publishing : Publishing steps are conditionally executed based on manual triggers and input parameters, allowing for flexible deployment strategies. By understanding these concurrency considerations, users can effectively manage and extend the CI/CD pipeline to suit their specific needs. AnnIndex - Brute-force Nearest Neighbor Search \u00b6 The AnnIndex class provides efficient brute-force nearest neighbor search with support for multiple distance metrics. Constructor \u00b6 AnnIndex(dim: int, metric: Distance) \u00b6 Creates a new brute-force index. dim (int): Vector dimension metric (Distance): Distance metric ( EUCLIDEAN , COSINE , MANHATTAN , CHEBYSHEV ) new_minkowski(dim: int, p: float) \u00b6 Creates a Minkowski distance index. dim (int): Vector dimension p (float): Minkowski exponent (p > 0) Methods \u00b6 add(data: ndarray, ids: ndarray) \u00b6 Add vectors to the index. data : N\u00d7dim array of float32 vectors ids : N-dimensional array of int64 IDs search(query: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Search for k nearest neighbors. query : dim-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances) search_batch(queries: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Batch search for multiple queries. queries : M\u00d7dim array of queries k : Number of neighbors per query Returns: (M\u00d7k IDs, M\u00d7k distances) search_filter_py(query: ndarray, k: int, filter_fn: Callable[[int], bool]) -> Tuple[ndarray, ndarray] \u00b6 Search with ID filtering. query : dim-dimensional query vector k : Maximum neighbors to return filter_fn : Function that returns True for allowed IDs Returns: (filtered IDs, filtered distances) save(path: str) \u00b6 Save index to disk. static load(path: str) -> AnnIndex \u00b6 Load index from disk. Example \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) PyHnswIndex - Approximate Nearest Neighbors with HNSW \u00b6 The PyHnswIndex class provides approximate nearest neighbor search using Hierarchical Navigable Small World (HNSW) graphs. Constructor \u00b6 PyHnswIndex(dims: int) \u00b6 Creates a new HNSW index. dims (int): Vector dimension Methods \u00b6 add(data: ndarray, ids: ndarray) \u00b6 Add vectors to the index. data : N\u00d7dims array of float32 vectors ids : N-dimensional array of int64 IDs search(vector: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Search for k approximate nearest neighbors. vector : dims-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances) save(path: str) \u00b6 Save index to disk. static load(path: str) -> PyHnswIndex \u00b6 Load index from disk (currently not implemented) Example \u00b6 import numpy as np from rust_annie import PyHnswIndex # Create index index = PyHnswIndex(dims=128) # Add data data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) ThreadSafeAnnIndex - Thread-safe Nearest Neighbor Index \u00b6 The ThreadSafeAnnIndex class provides a thread-safe wrapper around AnnIndex for concurrent access. Constructor \u00b6 ThreadSafeAnnIndex(dim: int, metric: Distance) \u00b6 Creates a new thread-safe index. dim (int): Vector dimension metric (Distance): Distance metric Methods \u00b6 add(data: ndarray, ids: ndarray) \u00b6 Thread-safe vector addition. remove(ids: List[int]) \u00b6 Thread-safe removal by IDs. search(query: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Thread-safe single query search. search_batch(queries: ndarray, k: int) -> Tuple[ndarray, ndarray] \u00b6 Thread-safe batch search. save(path: str) \u00b6 Thread-safe save. static load(path: str) -> ThreadSafeAnnIndex \u00b6 Thread-safe load. Example \u00b6 import numpy as np from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor # Create index index = ThreadSafeAnnIndex(128, Distance.COSINE) # Add data from multiple threads with ThreadPoolExecutor() as executor: for i in range(4): data = np.random.rand(250, 128).astype(np.float32) ids = np.arange(i*250, (i+1)*250, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent searches with ThreadPoolExecutor() as executor: futures = [] for _ in range(10): query = np.random.rand(128).astype(np.float32) futures.append(executor.submit(index.search, query, k=5)) for future in futures: ids, dists = future.result() Annie Examples \u00b6 Basic Usage \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Generate and add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Single query query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) # Batch queries queries = np.random.rand(10, 128).astype(np.float32) batch_ids, batch_dists = index.search_batch(queries, k=3) Filtered Search \u00b6 # Create index with sample data index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Define filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids) # Only IDs 10 and 30 will be returned (20 is odd) HNSW Index \u00b6 from rust_annie import PyHnswIndex # Create HNSW index index = PyHnswIndex(dims=128) # Add large dataset data = np.random.rand(100000, 128).astype(np.float32) ids = np.arange(100000, dtype=np.int64) index.add(data, ids) # Fast approximate search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) Saving and Loading \u00b6 # Create and save index index = AnnIndex(64, Distance.COSINE) data = np.random.rand(500, 64).astype(np.float32) ids = np.arange(500, dtype=np.int64) index.add(data, ids) index.save(\"my_index\") # Load index loaded_index = AnnIndex.load(\"my_index\") Thread-safe Operations \u00b6 from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor index = ThreadSafeAnnIndex(256, Distance.MANHATTAN) # Concurrent writes with ThreadPoolExecutor() as executor: for i in range(10): data = np.random.rand(100, 256).astype(np.float32) ids = np.arange(i*100, (i+1)*100, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent reads with ThreadPoolExecutor() as executor: futures = [] for _ in range(100): query = np.random.rand(256).astype(np.float32) futures.append(executor.submit(index.search, query, k=3)) results = [f.result() for f in futures] Minkowski Distance \u00b6 # Create index with custom distance index = AnnIndex.new_minkowski(dim=64, p=2.5) data = np.random.rand(200, 64).astype(np.float32) ids = np.arange(200, dtype=np.int64) index.add(data, ids) # Search with Minkowski distance query = np.random.rand(64).astype(np.float32) ids, dists = index.search(query, k=5) Filtering \u00b6 Why Filtering? \u00b6 Filters allow you to narrow down search results dynamically based on: - Metadata (e.g., tags, IDs, labels) - Numeric thresholds (e.g., only items above/below a value) - Custom user-defined logic This improves both precision and flexibility of search. Example: Python API \u00b6 from rust_annie import AnnIndex import numpy as np # 1. Create an index with vector dimension 128 index = AnnIndex(dimension=128) # 2. Add data with metadata vector0 = np.random.rand(128).astype(np.float32) vector1 = np.random.rand(128).astype(np.float32) index.add_item(0, vector0, metadata={\"category\": \"A\"}) index.add_item(1, vector1, metadata={\"category\": \"B\"}) # 3. Define a filter function (e.g., only include items where category == \"A\") def category_filter(metadata): return metadata.get(\"category\") == \"A\" # 4. Perform search with the filter applied query_vector = np.random.rand(128).astype(np.float32) results = index.search(query_vector, k=5, filter=category_filter) print(\"Filtered search results:\", results) Supported Filters \u00b6 This library supports applying filters to narrow down ANN search results dynamically. Filter type Example Equals Filter.equals(\"category\", \"A\") Greater than Filter.gt(\"score\", 0.8) Less than Filter.lt(\"price\", 100) Custom predicate Filter.custom(lambda metadata: ...) Filters work on the metadata you provide when adding items to the index. Sorting Behavior \u00b6 The BruteForceIndex now uses total_cmp for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons. Benchmarking Indices \u00b6 The library now includes a benchmarking function to evaluate the performance of different index types, specifically PyHnswIndex and AnnIndex . This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type. Example: Benchmarking Script \u00b6 import numpy as np import time from rust_annie import PyHnswIndex, AnnIndex def benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10): print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\") # Data data = np.random.rand(n, dim).astype(np.float32) ids = np.arange(n, dtype=np.int64) queries = np.random.rand(q, dim).astype(np.float32) # Index setup index = index_cls(dims=dim) index.add(data, ids) # Warm-up + Timing times = [] for i in range(q): start = time.perf_counter() _ = index.search(queries[i], k=k) times.append((time.perf_counter() - start) * 1000) print(f\" Avg query time: {np.mean(times):.3f} ms\") print(f\" Max query time: {np.max(times):.3f} ms\") print(f\" Min query time: {np.min(times):.3f} ms\") if __name__ == \"__main__\": benchmark(PyHnswIndex, \"HNSW\") benchmark(AnnIndex, \"Brute-Force\") Integration & Extensibility \u00b6 Filters are exposed from Rust to Python via PyO3 bindings. New filters can be added by extending src/filters.rs in the Rust code. Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API. See also \u00b6 Example usage: scripts/filter_example.py Unit tests covering filter behavior: tests/test_filters.py Benchmarking script: scripts/compare.py Annie Documentation \u00b6 Blazingly fast Approximate Nearest Neighbors in Rust Installation \u00b6 pip install rust_annie Basic Usage \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) Key Features \u00b6 Multiple distance metrics CPU/GPU acceleration Thread-safe indexes Filtered search HNSW support","title":"Concurrency"},{"location":"concurrency/#using-threadsafeannindex-and-pyhnswindex-for-concurrent-access","text":"Annie exposes a thread-safe version of its ANN index ( AnnIndex ) for use in Python. This is useful when you want to perform parallel search or update operations from Python threads. Additionally, the PyHnswIndex class provides a Python interface to the HNSW index, which now includes enhanced data handling capabilities.","title":"Using ThreadSafeAnnIndex and PyHnswIndex for Concurrent Access"},{"location":"concurrency/#key-features","text":"Safe concurrent read access ( search , search_batch ) Exclusive write access ( add , remove ) Backed by Rust RwLock and exposed via PyO3 PyHnswIndex supports mapping internal IDs to user IDs and handling vector data efficiently","title":"Key Features"},{"location":"concurrency/#example","text":"from annie import ThreadSafeAnnIndex, Distance import numpy as np import threading # Create index index = ThreadSafeAnnIndex(128, Distance.Cosine) # Add vectors data = np.random.rand(1000, 128).astype('float32') ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Run concurrent searches def run_search(): query = np.random.rand(128).astype('float32') ids, distances = index.search(query, 10) print(ids) threads = [threading.Thread(target=run_search) for _ in range(4)] [t.start() for t in threads] [t.join() for t in threads] # Using PyHnswIndex from rust_annie import PyHnswIndex # Create HNSW index hnsw_index = PyHnswIndex(dims=128) # Add vectors to HNSW index hnsw_index.add(data, ids) # Search in HNSW index query = np.random.rand(128).astype('float32') user_ids, distances = hnsw_index.search(query, 10) print(user_ids)","title":"Example"},{"location":"concurrency/#cicd-pipeline-for-pypi-publishing","text":"The CI/CD pipeline for PyPI publishing has been updated to include parallel jobs for building wheels and source distributions across multiple operating systems and Python versions. This involves concurrency considerations that should be documented for users who are integrating or maintaining the pipeline.","title":"CI/CD Pipeline for PyPI Publishing"},{"location":"concurrency/#pipeline-overview","text":"The pipeline is triggered on pushes and pull requests to the main branch, as well as manually via workflow_dispatch . It includes the following jobs: Test : Runs on ubuntu-latest and includes steps for checking out the code, setting up Rust, caching dependencies, running tests, and checking code formatting. Build Wheels : Runs in parallel across ubuntu-latest , windows-latest , and macos-latest for Python versions 3.8, 3.9, 3.10, and 3.11. This job builds the wheels using maturin and uploads them as artifacts. Build Source Distribution : Runs on ubuntu-latest and builds the source distribution using maturin , uploading it as an artifact. Publish to TestPyPI : Publishes the built artifacts to TestPyPI if triggered via workflow_dispatch with the appropriate input. Publish to PyPI : Publishes the built artifacts to PyPI if triggered via workflow_dispatch with the appropriate input.","title":"Pipeline Overview"},{"location":"concurrency/#concurrency-considerations","text":"Parallel Builds : The build-wheels job utilizes a matrix strategy to run builds concurrently across different operating systems and Python versions. This reduces the overall build time but requires careful management of dependencies and environment setup to ensure consistency across platforms. Artifact Management : Artifacts from parallel jobs are downloaded and flattened before publishing to ensure all necessary files are available in a single directory structure for the publish steps. Conditional Publishing : Publishing steps are conditionally executed based on manual triggers and input parameters, allowing for flexible deployment strategies. By understanding these concurrency considerations, users can effectively manage and extend the CI/CD pipeline to suit their specific needs.","title":"Concurrency Considerations"},{"location":"concurrency/#annindex-brute-force-nearest-neighbor-search","text":"The AnnIndex class provides efficient brute-force nearest neighbor search with support for multiple distance metrics.","title":"AnnIndex - Brute-force Nearest Neighbor Search"},{"location":"concurrency/#constructor","text":"","title":"Constructor"},{"location":"concurrency/#annindexdim-int-metric-distance","text":"Creates a new brute-force index. dim (int): Vector dimension metric (Distance): Distance metric ( EUCLIDEAN , COSINE , MANHATTAN , CHEBYSHEV )","title":"AnnIndex(dim: int, metric: Distance)"},{"location":"concurrency/#new_minkowskidim-int-p-float","text":"Creates a Minkowski distance index. dim (int): Vector dimension p (float): Minkowski exponent (p > 0)","title":"new_minkowski(dim: int, p: float)"},{"location":"concurrency/#methods","text":"","title":"Methods"},{"location":"concurrency/#adddata-ndarray-ids-ndarray","text":"Add vectors to the index. data : N\u00d7dim array of float32 vectors ids : N-dimensional array of int64 IDs","title":"add(data: ndarray, ids: ndarray)"},{"location":"concurrency/#searchquery-ndarray-k-int-tuplendarray-ndarray","text":"Search for k nearest neighbors. query : dim-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances)","title":"search(query: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#search_batchqueries-ndarray-k-int-tuplendarray-ndarray","text":"Batch search for multiple queries. queries : M\u00d7dim array of queries k : Number of neighbors per query Returns: (M\u00d7k IDs, M\u00d7k distances)","title":"search_batch(queries: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#search_filter_pyquery-ndarray-k-int-filter_fn-callableint-bool-tuplendarray-ndarray","text":"Search with ID filtering. query : dim-dimensional query vector k : Maximum neighbors to return filter_fn : Function that returns True for allowed IDs Returns: (filtered IDs, filtered distances)","title":"search_filter_py(query: ndarray, k: int, filter_fn: Callable[[int], bool]) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#savepath-str","text":"Save index to disk.","title":"save(path: str)"},{"location":"concurrency/#static-loadpath-str-annindex","text":"Load index from disk.","title":"static load(path: str) -&gt; AnnIndex"},{"location":"concurrency/#example_1","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Example"},{"location":"concurrency/#pyhnswindex-approximate-nearest-neighbors-with-hnsw","text":"The PyHnswIndex class provides approximate nearest neighbor search using Hierarchical Navigable Small World (HNSW) graphs.","title":"PyHnswIndex - Approximate Nearest Neighbors with HNSW"},{"location":"concurrency/#constructor_1","text":"","title":"Constructor"},{"location":"concurrency/#pyhnswindexdims-int","text":"Creates a new HNSW index. dims (int): Vector dimension","title":"PyHnswIndex(dims: int)"},{"location":"concurrency/#methods_1","text":"","title":"Methods"},{"location":"concurrency/#adddata-ndarray-ids-ndarray_1","text":"Add vectors to the index. data : N\u00d7dims array of float32 vectors ids : N-dimensional array of int64 IDs","title":"add(data: ndarray, ids: ndarray)"},{"location":"concurrency/#searchvector-ndarray-k-int-tuplendarray-ndarray","text":"Search for k approximate nearest neighbors. vector : dims-dimensional query vector k : Number of neighbors to return Returns: (neighbor IDs, distances)","title":"search(vector: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#savepath-str_1","text":"Save index to disk.","title":"save(path: str)"},{"location":"concurrency/#static-loadpath-str-pyhnswindex","text":"Load index from disk (currently not implemented)","title":"static load(path: str) -&gt; PyHnswIndex"},{"location":"concurrency/#example_2","text":"import numpy as np from rust_annie import PyHnswIndex # Create index index = PyHnswIndex(dims=128) # Add data data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"Example"},{"location":"concurrency/#threadsafeannindex-thread-safe-nearest-neighbor-index","text":"The ThreadSafeAnnIndex class provides a thread-safe wrapper around AnnIndex for concurrent access.","title":"ThreadSafeAnnIndex - Thread-safe Nearest Neighbor Index"},{"location":"concurrency/#constructor_2","text":"","title":"Constructor"},{"location":"concurrency/#threadsafeannindexdim-int-metric-distance","text":"Creates a new thread-safe index. dim (int): Vector dimension metric (Distance): Distance metric","title":"ThreadSafeAnnIndex(dim: int, metric: Distance)"},{"location":"concurrency/#methods_2","text":"","title":"Methods"},{"location":"concurrency/#adddata-ndarray-ids-ndarray_2","text":"Thread-safe vector addition.","title":"add(data: ndarray, ids: ndarray)"},{"location":"concurrency/#removeids-listint","text":"Thread-safe removal by IDs.","title":"remove(ids: List[int])"},{"location":"concurrency/#searchquery-ndarray-k-int-tuplendarray-ndarray_1","text":"Thread-safe single query search.","title":"search(query: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#search_batchqueries-ndarray-k-int-tuplendarray-ndarray_1","text":"Thread-safe batch search.","title":"search_batch(queries: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]"},{"location":"concurrency/#savepath-str_2","text":"Thread-safe save.","title":"save(path: str)"},{"location":"concurrency/#static-loadpath-str-threadsafeannindex","text":"Thread-safe load.","title":"static load(path: str) -&gt; ThreadSafeAnnIndex"},{"location":"concurrency/#example_3","text":"import numpy as np from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor # Create index index = ThreadSafeAnnIndex(128, Distance.COSINE) # Add data from multiple threads with ThreadPoolExecutor() as executor: for i in range(4): data = np.random.rand(250, 128).astype(np.float32) ids = np.arange(i*250, (i+1)*250, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent searches with ThreadPoolExecutor() as executor: futures = [] for _ in range(10): query = np.random.rand(128).astype(np.float32) futures.append(executor.submit(index.search, query, k=5)) for future in futures: ids, dists = future.result()","title":"Example"},{"location":"concurrency/#annie-examples","text":"","title":"Annie Examples"},{"location":"concurrency/#basic-usage","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Generate and add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Single query query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) # Batch queries queries = np.random.rand(10, 128).astype(np.float32) batch_ids, batch_dists = index.search_batch(queries, k=3)","title":"Basic Usage"},{"location":"concurrency/#filtered-search","text":"# Create index with sample data index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Define filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids) # Only IDs 10 and 30 will be returned (20 is odd)","title":"Filtered Search"},{"location":"concurrency/#hnsw-index","text":"from rust_annie import PyHnswIndex # Create HNSW index index = PyHnswIndex(dims=128) # Add large dataset data = np.random.rand(100000, 128).astype(np.float32) ids = np.arange(100000, dtype=np.int64) index.add(data, ids) # Fast approximate search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"HNSW Index"},{"location":"concurrency/#saving-and-loading","text":"# Create and save index index = AnnIndex(64, Distance.COSINE) data = np.random.rand(500, 64).astype(np.float32) ids = np.arange(500, dtype=np.int64) index.add(data, ids) index.save(\"my_index\") # Load index loaded_index = AnnIndex.load(\"my_index\")","title":"Saving and Loading"},{"location":"concurrency/#thread-safe-operations","text":"from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor index = ThreadSafeAnnIndex(256, Distance.MANHATTAN) # Concurrent writes with ThreadPoolExecutor() as executor: for i in range(10): data = np.random.rand(100, 256).astype(np.float32) ids = np.arange(i*100, (i+1)*100, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent reads with ThreadPoolExecutor() as executor: futures = [] for _ in range(100): query = np.random.rand(256).astype(np.float32) futures.append(executor.submit(index.search, query, k=3)) results = [f.result() for f in futures]","title":"Thread-safe Operations"},{"location":"concurrency/#minkowski-distance","text":"# Create index with custom distance index = AnnIndex.new_minkowski(dim=64, p=2.5) data = np.random.rand(200, 64).astype(np.float32) ids = np.arange(200, dtype=np.int64) index.add(data, ids) # Search with Minkowski distance query = np.random.rand(64).astype(np.float32) ids, dists = index.search(query, k=5)","title":"Minkowski Distance"},{"location":"concurrency/#filtering","text":"","title":"Filtering"},{"location":"concurrency/#why-filtering","text":"Filters allow you to narrow down search results dynamically based on: - Metadata (e.g., tags, IDs, labels) - Numeric thresholds (e.g., only items above/below a value) - Custom user-defined logic This improves both precision and flexibility of search.","title":"Why Filtering?"},{"location":"concurrency/#example-python-api","text":"from rust_annie import AnnIndex import numpy as np # 1. Create an index with vector dimension 128 index = AnnIndex(dimension=128) # 2. Add data with metadata vector0 = np.random.rand(128).astype(np.float32) vector1 = np.random.rand(128).astype(np.float32) index.add_item(0, vector0, metadata={\"category\": \"A\"}) index.add_item(1, vector1, metadata={\"category\": \"B\"}) # 3. Define a filter function (e.g., only include items where category == \"A\") def category_filter(metadata): return metadata.get(\"category\") == \"A\" # 4. Perform search with the filter applied query_vector = np.random.rand(128).astype(np.float32) results = index.search(query_vector, k=5, filter=category_filter) print(\"Filtered search results:\", results)","title":"Example: Python API"},{"location":"concurrency/#supported-filters","text":"This library supports applying filters to narrow down ANN search results dynamically. Filter type Example Equals Filter.equals(\"category\", \"A\") Greater than Filter.gt(\"score\", 0.8) Less than Filter.lt(\"price\", 100) Custom predicate Filter.custom(lambda metadata: ...) Filters work on the metadata you provide when adding items to the index.","title":"Supported Filters"},{"location":"concurrency/#sorting-behavior","text":"The BruteForceIndex now uses total_cmp for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons.","title":"Sorting Behavior"},{"location":"concurrency/#benchmarking-indices","text":"The library now includes a benchmarking function to evaluate the performance of different index types, specifically PyHnswIndex and AnnIndex . This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type.","title":"Benchmarking Indices"},{"location":"concurrency/#example-benchmarking-script","text":"import numpy as np import time from rust_annie import PyHnswIndex, AnnIndex def benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10): print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\") # Data data = np.random.rand(n, dim).astype(np.float32) ids = np.arange(n, dtype=np.int64) queries = np.random.rand(q, dim).astype(np.float32) # Index setup index = index_cls(dims=dim) index.add(data, ids) # Warm-up + Timing times = [] for i in range(q): start = time.perf_counter() _ = index.search(queries[i], k=k) times.append((time.perf_counter() - start) * 1000) print(f\" Avg query time: {np.mean(times):.3f} ms\") print(f\" Max query time: {np.max(times):.3f} ms\") print(f\" Min query time: {np.min(times):.3f} ms\") if __name__ == \"__main__\": benchmark(PyHnswIndex, \"HNSW\") benchmark(AnnIndex, \"Brute-Force\")","title":"Example: Benchmarking Script"},{"location":"concurrency/#integration-extensibility","text":"Filters are exposed from Rust to Python via PyO3 bindings. New filters can be added by extending src/filters.rs in the Rust code. Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API.","title":"Integration &amp; Extensibility"},{"location":"concurrency/#see-also","text":"Example usage: scripts/filter_example.py Unit tests covering filter behavior: tests/test_filters.py Benchmarking script: scripts/compare.py","title":"See also"},{"location":"concurrency/#annie-documentation","text":"Blazingly fast Approximate Nearest Neighbors in Rust","title":"Annie Documentation"},{"location":"concurrency/#installation","text":"pip install rust_annie","title":"Installation"},{"location":"concurrency/#basic-usage_1","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Basic Usage"},{"location":"concurrency/#key-features_1","text":"Multiple distance metrics CPU/GPU acceleration Thread-safe indexes Filtered search HNSW support","title":"Key Features"},{"location":"contributing/","text":"Contributing to Annie Documentation \u00b6 Thank you for your interest in contributing to Annie's documentation! This guide will help you get started with contributing to our documentation site. Table of Contents \u00b6 Getting Started Documentation Structure Setting Up Development Environment Making Changes Writing Guidelines Submitting Changes Review Process Getting Started \u00b6 Prerequisites \u00b6 Python 3.8+ Git Text editor or IDE Quick Setup \u00b6 Fork and Clone bash git clone https://github.com/YOUR-USERNAME/Annie-Docs.git cd Annie-Docs Build Documentation bash ./build-docs.sh Start Development Server bash source venv/bin/activate mkdocs serve Open in Browser Visit http://localhost:8000 to see your changes live. Documentation Structure \u00b6 docs/ \u251c\u2500\u2500 index.md # Homepage \u251c\u2500\u2500 api/ # API Reference \u2502 \u251c\u2500\u2500 ann_index.md # AnnIndex class \u2502 \u251c\u2500\u2500 hnsw_index.md # PyHnswIndex class \u2502 \u2514\u2500\u2500 threadsafe_index.md \u251c\u2500\u2500 examples.md # Usage examples \u251c\u2500\u2500 concurrency.md # Thread-safety features \u2514\u2500\u2500 filtering.md # Filtered search Setting Up Development Environment \u00b6 Manual Setup \u00b6 # Create virtual environment python3 -m venv venv source venv/bin/activate # Install dependencies pip install -r requirements.txt # Build site mkdocs build # Serve locally with auto-reload mkdocs serve --dev-addr=0.0.0.0:8000 Using Scripts \u00b6 # Build documentation ./build-docs.sh # Deploy (build + prepare for hosting) ./deploy.sh Making Changes \u00b6 Types of Contributions \u00b6 Bug Fixes : Typos, broken links, formatting issues Content Updates : New examples, clarifications, additional details New Documentation : New features, API additions Structure Improvements : Navigation, organization, user experience Workflow \u00b6 Create a Branch bash git checkout -b feature/improve-examples Make Your Changes Edit files in the docs/ directory Use Markdown syntax Follow our writing guidelines Test Locally bash mkdocs serve Visit http://localhost:8000 to review changes Build and Verify bash mkdocs build Ensure no build errors Writing Guidelines \u00b6 Markdown Standards \u00b6 Use # for main headings, ## for sections, ### for subsections Use code blocks with language specification: python # Good import numpy as np Use **bold** for emphasis, *italic* for secondary emphasis Use backticks for inline code and class names like AnnIndex Code Examples \u00b6 Complete Examples : Show full working code Clear Comments : Explain what each section does Realistic Data : Use meaningful variable names and realistic scenarios Error Handling : Include error handling where appropriate # Good example import numpy as np from rust_annie import AnnIndex, Distance # Create index for 128-dimensional vectors index = AnnIndex(128, Distance.EUCLIDEAN) # Add sample data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search for nearest neighbors query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) print(f\"Found {len(neighbor_ids)} neighbors\") API Documentation \u00b6 Class Descriptions : Clear purpose and use cases Parameter Details : Type, description, constraints Return Values : What the method returns Examples : Show typical usage Error Conditions : When methods might fail Writing Style \u00b6 Clear and Concise : Get to the point quickly Beginner-Friendly : Explain concepts that might be unfamiliar Consistent Terminology : Use the same terms throughout Active Voice : \"Create an index\" vs \"An index is created\" Submitting Changes \u00b6 Before Submitting \u00b6 Test Your Changes bash mkdocs build # Check for build errors mkdocs serve # Test locally Check Links Ensure all internal links work Verify external links are accessible Review Content Proofread for typos and grammar Ensure code examples work Check formatting consistency Creating a Pull Request \u00b6 Commit Your Changes bash git add . git commit -m \"docs: improve examples in filtering.md\" Push to Your Fork bash git push origin feature/improve-examples Create Pull Request Go to GitHub and create a pull request Use a descriptive title Explain what you changed and why Reference any related issues Pull Request Template \u00b6 ## Description Brief description of changes made. ## Type of Change - [ ] Bug fix (typo, broken link, etc.) - [ ] Content update (new examples, clarifications) - [ ] New documentation (new features) - [ ] Structure improvement ## Testing - [ ] Built successfully with `mkdocs build` - [ ] Tested locally with `mkdocs serve` - [ ] Checked all links work - [ ] Verified code examples run ## Screenshots (if applicable) Add screenshots of significant visual changes. Review Process \u00b6 What We Look For \u00b6 Accuracy : Information is correct and up-to-date Clarity : Content is easy to understand Completeness : Examples work and are comprehensive Consistency : Follows existing style and structure Value : Genuinely helpful to users Review Timeline \u00b6 Initial Review : Within 2-3 days Feedback : We'll provide specific suggestions Approval : Once all feedback is addressed After Approval \u00b6 Changes are merged to main branch Documentation is automatically deployed Your contribution is credited Issue Labels \u00b6 When creating issues, use these labels: documentation - General documentation issues bug - Errors in docs (typos, broken links) enhancement - Improvements to existing content new-content - Requests for new documentation good-first-issue - Good for newcomers Getting Help \u00b6 GitHub Discussions : Ask questions about contributing Issues : Report bugs or request features Thank you for helping make Annie's documentation better!","title":"Contributing"},{"location":"contributing/#contributing-to-annie-documentation","text":"Thank you for your interest in contributing to Annie's documentation! This guide will help you get started with contributing to our documentation site.","title":"Contributing to Annie Documentation"},{"location":"contributing/#table-of-contents","text":"Getting Started Documentation Structure Setting Up Development Environment Making Changes Writing Guidelines Submitting Changes Review Process","title":"Table of Contents"},{"location":"contributing/#getting-started","text":"","title":"Getting Started"},{"location":"contributing/#prerequisites","text":"Python 3.8+ Git Text editor or IDE","title":"Prerequisites"},{"location":"contributing/#quick-setup","text":"Fork and Clone bash git clone https://github.com/YOUR-USERNAME/Annie-Docs.git cd Annie-Docs Build Documentation bash ./build-docs.sh Start Development Server bash source venv/bin/activate mkdocs serve Open in Browser Visit http://localhost:8000 to see your changes live.","title":"Quick Setup"},{"location":"contributing/#documentation-structure","text":"docs/ \u251c\u2500\u2500 index.md # Homepage \u251c\u2500\u2500 api/ # API Reference \u2502 \u251c\u2500\u2500 ann_index.md # AnnIndex class \u2502 \u251c\u2500\u2500 hnsw_index.md # PyHnswIndex class \u2502 \u2514\u2500\u2500 threadsafe_index.md \u251c\u2500\u2500 examples.md # Usage examples \u251c\u2500\u2500 concurrency.md # Thread-safety features \u2514\u2500\u2500 filtering.md # Filtered search","title":"Documentation Structure"},{"location":"contributing/#setting-up-development-environment","text":"","title":"Setting Up Development Environment"},{"location":"contributing/#manual-setup","text":"# Create virtual environment python3 -m venv venv source venv/bin/activate # Install dependencies pip install -r requirements.txt # Build site mkdocs build # Serve locally with auto-reload mkdocs serve --dev-addr=0.0.0.0:8000","title":"Manual Setup"},{"location":"contributing/#using-scripts","text":"# Build documentation ./build-docs.sh # Deploy (build + prepare for hosting) ./deploy.sh","title":"Using Scripts"},{"location":"contributing/#making-changes","text":"","title":"Making Changes"},{"location":"contributing/#types-of-contributions","text":"Bug Fixes : Typos, broken links, formatting issues Content Updates : New examples, clarifications, additional details New Documentation : New features, API additions Structure Improvements : Navigation, organization, user experience","title":"Types of Contributions"},{"location":"contributing/#workflow","text":"Create a Branch bash git checkout -b feature/improve-examples Make Your Changes Edit files in the docs/ directory Use Markdown syntax Follow our writing guidelines Test Locally bash mkdocs serve Visit http://localhost:8000 to review changes Build and Verify bash mkdocs build Ensure no build errors","title":"Workflow"},{"location":"contributing/#writing-guidelines","text":"","title":"Writing Guidelines"},{"location":"contributing/#markdown-standards","text":"Use # for main headings, ## for sections, ### for subsections Use code blocks with language specification: python # Good import numpy as np Use **bold** for emphasis, *italic* for secondary emphasis Use backticks for inline code and class names like AnnIndex","title":"Markdown Standards"},{"location":"contributing/#code-examples","text":"Complete Examples : Show full working code Clear Comments : Explain what each section does Realistic Data : Use meaningful variable names and realistic scenarios Error Handling : Include error handling where appropriate # Good example import numpy as np from rust_annie import AnnIndex, Distance # Create index for 128-dimensional vectors index = AnnIndex(128, Distance.EUCLIDEAN) # Add sample data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search for nearest neighbors query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) print(f\"Found {len(neighbor_ids)} neighbors\")","title":"Code Examples"},{"location":"contributing/#api-documentation","text":"Class Descriptions : Clear purpose and use cases Parameter Details : Type, description, constraints Return Values : What the method returns Examples : Show typical usage Error Conditions : When methods might fail","title":"API Documentation"},{"location":"contributing/#writing-style","text":"Clear and Concise : Get to the point quickly Beginner-Friendly : Explain concepts that might be unfamiliar Consistent Terminology : Use the same terms throughout Active Voice : \"Create an index\" vs \"An index is created\"","title":"Writing Style"},{"location":"contributing/#submitting-changes","text":"","title":"Submitting Changes"},{"location":"contributing/#before-submitting","text":"Test Your Changes bash mkdocs build # Check for build errors mkdocs serve # Test locally Check Links Ensure all internal links work Verify external links are accessible Review Content Proofread for typos and grammar Ensure code examples work Check formatting consistency","title":"Before Submitting"},{"location":"contributing/#creating-a-pull-request","text":"Commit Your Changes bash git add . git commit -m \"docs: improve examples in filtering.md\" Push to Your Fork bash git push origin feature/improve-examples Create Pull Request Go to GitHub and create a pull request Use a descriptive title Explain what you changed and why Reference any related issues","title":"Creating a Pull Request"},{"location":"contributing/#pull-request-template","text":"## Description Brief description of changes made. ## Type of Change - [ ] Bug fix (typo, broken link, etc.) - [ ] Content update (new examples, clarifications) - [ ] New documentation (new features) - [ ] Structure improvement ## Testing - [ ] Built successfully with `mkdocs build` - [ ] Tested locally with `mkdocs serve` - [ ] Checked all links work - [ ] Verified code examples run ## Screenshots (if applicable) Add screenshots of significant visual changes.","title":"Pull Request Template"},{"location":"contributing/#review-process","text":"","title":"Review Process"},{"location":"contributing/#what-we-look-for","text":"Accuracy : Information is correct and up-to-date Clarity : Content is easy to understand Completeness : Examples work and are comprehensive Consistency : Follows existing style and structure Value : Genuinely helpful to users","title":"What We Look For"},{"location":"contributing/#review-timeline","text":"Initial Review : Within 2-3 days Feedback : We'll provide specific suggestions Approval : Once all feedback is addressed","title":"Review Timeline"},{"location":"contributing/#after-approval","text":"Changes are merged to main branch Documentation is automatically deployed Your contribution is credited","title":"After Approval"},{"location":"contributing/#issue-labels","text":"When creating issues, use these labels: documentation - General documentation issues bug - Errors in docs (typos, broken links) enhancement - Improvements to existing content new-content - Requests for new documentation good-first-issue - Good for newcomers","title":"Issue Labels"},{"location":"contributing/#getting-help","text":"GitHub Discussions : Ask questions about contributing Issues : Report bugs or request features Thank you for helping make Annie's documentation better!","title":"Getting Help"},{"location":"examples/","text":"Annie Examples \u00b6 Basic Usage \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Generate and add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Single query query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) # Batch queries queries = np.random.rand(10, 128).astype(np.float32) batch_ids, batch_dists = index.search_batch(queries, k=3) Filtered Search \u00b6 # Create index with sample data index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Define filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids) # Only IDs 10 and 30 will be returned (20 is odd) HNSW Index \u00b6 from rust_annie import PyHnswIndex # Create HNSW index index = PyHnswIndex(dims=128) # Add large dataset data = np.random.rand(100000, 128).astype(np.float32) ids = np.arange(100000, dtype=np.int64) index.add(data, ids) # Fast approximate search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) Saving and Loading \u00b6 # Create and save index index = AnnIndex(64, Distance.COSINE) data = np.random.rand(500, 64).astype(np.float32) ids = np.arange(500, dtype=np.int64) index.add(data, ids) index.save(\"my_index\") # Load index loaded_index = AnnIndex.load(\"my_index\") Thread-safe Operations \u00b6 from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor index = ThreadSafeAnnIndex(256, Distance.MANHATTAN) # Concurrent writes with ThreadPoolExecutor() as executor: for i in range(10): data = np.random.rand(100, 256).astype(np.float32) ids = np.arange(i*100, (i+1)*100, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent reads with ThreadPoolExecutor() as executor: futures = [] for _ in range(100): query = np.random.rand(256).astype(np.float32) futures.append(executor.submit(index.search, query, k=3)) results = [f.result() for f in futures] Minkowski Distance \u00b6 # Create index with custom distance index = AnnIndex.new_minkowski(dim=64, p=2.5) data = np.random.rand(200, 64).astype(np.float32) ids = np.arange(200, dtype=np.int64) index.add(data, ids) # Search with Minkowski distance query = np.random.rand(64).astype(np.float32) ids, dists = index.search(query, k=5) README \u00b6 A lightning-fast, Rust-powered Approximate Nearest Neighbor library for Python with multiple backends, thread-safety, and GPU acceleration. Table of Contents \u00b6 Features Installation Quick Start Examples Brute-Force Index HNSW Index Thread-Safe Index Benchmark Results API Reference Development & CI GPU Acceleration Documentation Contributing License Features \u00b6 Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking Installation \u00b6 # Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release Quick Start \u00b6 Brute-Force Index \u00b6 import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) HNSW Index \u00b6 from rust_annie import PyHnswIndex index = PyHnswIndex(dims=128) data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10) Examples \u00b6 Brute-Force Index \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(4, Distance.COSINE) # Add data data = np.random.rand(50, 4).astype(np.float32) ids = np.arange(50, dtype=np.int64) idx.add(data, ids) # Search labels, dists = idx.search(data[10], k=3) print(labels, dists) Batch Query \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(16, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 16).astype(np.float32) ids = np.arange(1000, dtype=np.int64) idx.add(data, ids) # Batch search queries = data[:32] labels_batch, dists_batch = idx.search_batch(queries, k=10) print(labels_batch.shape) # (32, 10) Thread-Safe Index \u00b6 from rust_annie import ThreadSafeAnnIndex, Distance import numpy as np from concurrent.futures import ThreadPoolExecutor # Create thread-safe index idx = ThreadSafeAnnIndex(32, Distance.EUCLIDEAN) # Add data data = np.random.rand(500, 32).astype(np.float32) ids = np.arange(500, dtype=np.int64) idx.add(data, ids) # Concurrent searches def task(q): return idx.search(q, k=5) queries = np.random.rand(100, 32).astype(np.float32) with ThreadPoolExecutor(max_workers=8) as executor: futures = [executor.submit(task, q) for q in queries] for f in futures: print(f.result()) Filtered Search \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out) Build and Query a Brute-Force AnnIndex in Python (Complete Example) \u00b6 This section demonstrates a complete, beginner-friendly example of how to build and query a brute-force AnnIndex using Python. Measured on a 6-core CPU: That\u2019s a \\~4\u00d7 speedup vs. NumPy! Operation Dataset Size Time (ms) Speedup vs Python Single Query (Brute) 10,000 \u00d7 64 0.7 4\u00d7 Batch Query (64) 10,000 \u00d7 64 0.23 12\u00d7 HNSW Query 100,000 \u00d7 128 0.05 56\u00d7 View Full Benchmark Dashboard \u2192 \u00b6 You\u2019ll find: API Reference \u00b6 AnnIndex \u00b6 Create a brute-force k-NN index. Enum: Distance.EUCLIDEAN , Distance.COSINE , Distance.MANHATTAN ThreadSafeAnnIndex \u00b6 Same API as AnnIndex , safe for concurrent use. Core Classes \u00b6 Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc) Key Methods \u00b6 Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search save(path) Save index to disk load(path) Load index from disk Development & CI \u00b6 CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation Benchmark Automation \u00b6 Benchmarks are tracked over time using: GPU Acceleration \u00b6 Enable GPU in Rust \u00b6 Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed Contributing \u00b6 Contributions are welcome! Please: See ../docs-management/CONTRIBUTING.md for details. License \u00b6 This project is licensed under the MIT License . See LICENSE for details.","title":"Examples"},{"location":"examples/#annie-examples","text":"","title":"Annie Examples"},{"location":"examples/#basic-usage","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Generate and add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Single query query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5) # Batch queries queries = np.random.rand(10, 128).astype(np.float32) batch_ids, batch_dists = index.search_batch(queries, k=3)","title":"Basic Usage"},{"location":"examples/#filtered-search","text":"# Create index with sample data index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Define filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids) # Only IDs 10 and 30 will be returned (20 is odd)","title":"Filtered Search"},{"location":"examples/#hnsw-index","text":"from rust_annie import PyHnswIndex # Create HNSW index index = PyHnswIndex(dims=128) # Add large dataset data = np.random.rand(100000, 128).astype(np.float32) ids = np.arange(100000, dtype=np.int64) index.add(data, ids) # Fast approximate search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"HNSW Index"},{"location":"examples/#saving-and-loading","text":"# Create and save index index = AnnIndex(64, Distance.COSINE) data = np.random.rand(500, 64).astype(np.float32) ids = np.arange(500, dtype=np.int64) index.add(data, ids) index.save(\"my_index\") # Load index loaded_index = AnnIndex.load(\"my_index\")","title":"Saving and Loading"},{"location":"examples/#thread-safe-operations","text":"from rust_annie import ThreadSafeAnnIndex, Distance from concurrent.futures import ThreadPoolExecutor index = ThreadSafeAnnIndex(256, Distance.MANHATTAN) # Concurrent writes with ThreadPoolExecutor() as executor: for i in range(10): data = np.random.rand(100, 256).astype(np.float32) ids = np.arange(i*100, (i+1)*100, dtype=np.int64) executor.submit(index.add, data, ids) # Concurrent reads with ThreadPoolExecutor() as executor: futures = [] for _ in range(100): query = np.random.rand(256).astype(np.float32) futures.append(executor.submit(index.search, query, k=3)) results = [f.result() for f in futures]","title":"Thread-safe Operations"},{"location":"examples/#minkowski-distance","text":"# Create index with custom distance index = AnnIndex.new_minkowski(dim=64, p=2.5) data = np.random.rand(200, 64).astype(np.float32) ids = np.arange(200, dtype=np.int64) index.add(data, ids) # Search with Minkowski distance query = np.random.rand(64).astype(np.float32) ids, dists = index.search(query, k=5)","title":"Minkowski Distance"},{"location":"examples/#readme","text":"A lightning-fast, Rust-powered Approximate Nearest Neighbor library for Python with multiple backends, thread-safety, and GPU acceleration.","title":"README"},{"location":"examples/#table-of-contents","text":"Features Installation Quick Start Examples Brute-Force Index HNSW Index Thread-Safe Index Benchmark Results API Reference Development & CI GPU Acceleration Documentation Contributing License","title":"Table of Contents"},{"location":"examples/#features","text":"Multiple Backends : Brute-force (exact) with SIMD acceleration HNSW (approximate) for large-scale datasets Multiple Distance Metrics : Euclidean, Cosine, Manhattan, Chebyshev Batch Queries for efficient processing Thread-safe indexes with concurrent access Zero-copy NumPy integration On-disk Persistence with serialization Filtered Search with custom Python callbacks GPU Acceleration for brute-force calculations Multi-platform support (Linux, Windows, macOS) Automated CI with performance tracking","title":"Features"},{"location":"examples/#installation","text":"# Stable release from PyPI: pip install rust-annie # Install with GPU support (requires CUDA): pip install rust-annie[gpu] # Or install from source: git clone https://github.com/Programmers-Paradise/Annie.git cd Annie pip install maturin maturin develop --release","title":"Installation"},{"location":"examples/#quick-start","text":"","title":"Quick Start"},{"location":"examples/#brute-force-index","text":"import numpy as np from rust_annie import AnnIndex, Distance # Create index index = AnnIndex(128, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 128).astype(np.float32) ids = np.arange(1000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, distances = index.search(query, k=5)","title":"Brute-Force Index"},{"location":"examples/#hnsw-index_1","text":"from rust_annie import PyHnswIndex index = PyHnswIndex(dims=128) data = np.random.rand(10000, 128).astype(np.float32) ids = np.arange(10000, dtype=np.int64) index.add(data, ids) # Search query = np.random.rand(128).astype(np.float32) neighbor_ids, _ = index.search(query, k=10)","title":"HNSW Index"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#brute-force-index_1","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(4, Distance.COSINE) # Add data data = np.random.rand(50, 4).astype(np.float32) ids = np.arange(50, dtype=np.int64) idx.add(data, ids) # Search labels, dists = idx.search(data[10], k=3) print(labels, dists)","title":"Brute-Force Index"},{"location":"examples/#batch-query","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index idx = AnnIndex(16, Distance.EUCLIDEAN) # Add data data = np.random.rand(1000, 16).astype(np.float32) ids = np.arange(1000, dtype=np.int64) idx.add(data, ids) # Batch search queries = data[:32] labels_batch, dists_batch = idx.search_batch(queries, k=10) print(labels_batch.shape) # (32, 10)","title":"Batch Query"},{"location":"examples/#thread-safe-index","text":"from rust_annie import ThreadSafeAnnIndex, Distance import numpy as np from concurrent.futures import ThreadPoolExecutor # Create thread-safe index idx = ThreadSafeAnnIndex(32, Distance.EUCLIDEAN) # Add data data = np.random.rand(500, 32).astype(np.float32) ids = np.arange(500, dtype=np.int64) idx.add(data, ids) # Concurrent searches def task(q): return idx.search(q, k=5) queries = np.random.rand(100, 32).astype(np.float32) with ThreadPoolExecutor(max_workers=8) as executor: futures = [executor.submit(task, q) for q in queries] for f in futures: print(f.result())","title":"Thread-Safe Index"},{"location":"examples/#filtered-search_1","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out)","title":"Filtered Search"},{"location":"examples/#build-and-query-a-brute-force-annindex-in-python-complete-example","text":"This section demonstrates a complete, beginner-friendly example of how to build and query a brute-force AnnIndex using Python. Measured on a 6-core CPU: That\u2019s a \\~4\u00d7 speedup vs. NumPy! Operation Dataset Size Time (ms) Speedup vs Python Single Query (Brute) 10,000 \u00d7 64 0.7 4\u00d7 Batch Query (64) 10,000 \u00d7 64 0.23 12\u00d7 HNSW Query 100,000 \u00d7 128 0.05 56\u00d7","title":"Build and Query a Brute-Force AnnIndex in Python (Complete Example)"},{"location":"examples/#view-full-benchmark-dashboard","text":"You\u2019ll find:","title":"View Full Benchmark Dashboard \u2192"},{"location":"examples/#api-reference","text":"","title":"API Reference"},{"location":"examples/#annindex","text":"Create a brute-force k-NN index. Enum: Distance.EUCLIDEAN , Distance.COSINE , Distance.MANHATTAN","title":"AnnIndex"},{"location":"examples/#threadsafeannindex","text":"Same API as AnnIndex , safe for concurrent use.","title":"ThreadSafeAnnIndex"},{"location":"examples/#core-classes","text":"Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc)","title":"Core Classes"},{"location":"examples/#key-methods","text":"Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search save(path) Save index to disk load(path) Load index from disk","title":"Key Methods"},{"location":"examples/#development-ci","text":"CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus: benchmark.py & batch_benchmark.py & compare_results.py # Run tests cargo test pytest tests/ # Run benchmarks python scripts/benchmark.py python scripts/batch_benchmark.py # Generate documentation mkdocs build CI pipeline includes: - Cross-platform builds (Linux, Windows, macOS) - Unit tests and integration tests - Performance benchmarking - Documentation generation","title":"Development &amp; CI"},{"location":"examples/#benchmark-automation","text":"Benchmarks are tracked over time using:","title":"Benchmark Automation"},{"location":"examples/#gpu-acceleration","text":"","title":"GPU Acceleration"},{"location":"examples/#enable-gpu-in-rust","text":"Enable CUDA support for brute-force calculations: # Install with GPU support pip install rust-annie[gpu] # Or build from source with GPU features maturin develop --release --features gpu Supported operations: - Batch L2 distance calculations - High-dimensional similarity search Requirements: - NVIDIA GPU with CUDA support - CUDA Toolkit installed","title":"Enable GPU in Rust"},{"location":"examples/#contributing","text":"Contributions are welcome! Please: See ../docs-management/CONTRIBUTING.md for details.","title":"Contributing"},{"location":"examples/#license","text":"This project is licensed under the MIT License . See LICENSE for details.","title":"License"},{"location":"filtering/","text":"## ANN Search Filtering This document explains how to use the filtering capabilities to improve Approximate Nearest Neighbor (ANN) search. ### Why Filtering? Filters allow you to narrow down search results dynamically based on: - Metadata (e.g., tags, IDs, labels) - Numeric thresholds (e.g., only items above/below a value) - Custom user-defined logic This improves both precision and flexibility of search. #### Example: Python API ```python from rust_annie import AnnIndex import numpy as np # 1. Create an index with vector dimension 128 index = AnnIndex(dimension=128) # 2. Add data with metadata vector0 = np.random.rand(128).astype(np.float32) vector1 = np.random.rand(128).astype(np.float32) index.add_item(0, vector0, metadata={\"category\": \"A\"}) index.add_item(1, vector1, metadata={\"category\": \"B\"}) # 3. Define a filter function (e.g., only include items where category == \"A\") def category_filter(metadata): return metadata.get(\"category\") == \"A\" # 4. Perform search with the filter applied query_vector = np.random.rand(128).astype(np.float32) results = index.search(query_vector, k=5, filter=category_filter) print(\"Filtered search results:\", results) Supported Filters \u00b6 This library supports applying filters to narrow down ANN search results dynamically. Filter type Example Equals Filter.equals(\"category\", \"A\") Greater than Filter.gt(\"score\", 0.8) Less than Filter.lt(\"price\", 100) Custom predicate Filter.custom(lambda metadata: ...) Filters work on the metadata you provide when adding items to the index. New Feature: Filtered Search with Custom Python Callbacks \u00b6 The library now supports filtered search using custom Python callbacks, allowing for more complex filtering logic directly in Python. Example: Filtered Search with Python Callback \u00b6 from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out) Sorting Behavior \u00b6 The BruteForceIndex now uses total_cmp for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons. Benchmarking Indices \u00b6 The library now includes a benchmarking function to evaluate the performance of different index types, specifically PyHnswIndex and AnnIndex . This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type. Example: Benchmarking Script \u00b6 import numpy as np import time from rust_annie import PyHnswIndex, AnnIndex def benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10): print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\") # Data data = np.random.rand(n, dim).astype(np.float32) ids = np.arange(n, dtype=np.int64) queries = np.random.rand(q, dim).astype(np.float32) # Index setup index = index_cls(dims=dim) index.add(data, ids) # Warm-up + Timing times = [] for i in range(q): start = time.perf_counter() _ = index.search(queries[i], k=k) times.append((time.perf_counter() - start) * 1000) print(f\" Avg query time: {np.mean(times):.3f} ms\") print(f\" Max query time: {np.max(times):.3f} ms\") print(f\" Min query time: {np.min(times):.3f} ms\") if __name__ == \"__main__\": benchmark(PyHnswIndex, \"HNSW\") benchmark(AnnIndex, \"Brute-Force\") Integration & Extensibility \u00b6 Filters are exposed from Rust to Python via PyO3 bindings. New filters can be added by extending src/filters.rs in the Rust code. Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API. See also \u00b6 Example usage: scripts/filter_example.py Unit tests covering filter behavior: tests/test_filters.py Benchmarking script: scripts/compare.py ```","title":"Filtered Search"},{"location":"filtering/#supported-filters","text":"This library supports applying filters to narrow down ANN search results dynamically. Filter type Example Equals Filter.equals(\"category\", \"A\") Greater than Filter.gt(\"score\", 0.8) Less than Filter.lt(\"price\", 100) Custom predicate Filter.custom(lambda metadata: ...) Filters work on the metadata you provide when adding items to the index.","title":"Supported Filters"},{"location":"filtering/#new-feature-filtered-search-with-custom-python-callbacks","text":"The library now supports filtered search using custom Python callbacks, allowing for more complex filtering logic directly in Python.","title":"New Feature: Filtered Search with Custom Python Callbacks"},{"location":"filtering/#example-filtered-search-with-python-callback","text":"from rust_annie import AnnIndex, Distance import numpy as np # Create index index = AnnIndex(3, Distance.EUCLIDEAN) data = np.array([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ], dtype=np.float32) ids = np.array([10, 20, 30], dtype=np.int64) index.add(data, ids) # Filter function def even_ids(id: int) -> bool: return id % 2 == 0 # Filtered search query = np.array([1.0, 2.0, 3.0], dtype=np.float32) filtered_ids, filtered_dists = index.search_filter_py( query, k=3, filter_fn=even_ids ) print(filtered_ids) # [10, 30] (20 is filtered out)","title":"Example: Filtered Search with Python Callback"},{"location":"filtering/#sorting-behavior","text":"The BruteForceIndex now uses total_cmp for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons.","title":"Sorting Behavior"},{"location":"filtering/#benchmarking-indices","text":"The library now includes a benchmarking function to evaluate the performance of different index types, specifically PyHnswIndex and AnnIndex . This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type.","title":"Benchmarking Indices"},{"location":"filtering/#example-benchmarking-script","text":"import numpy as np import time from rust_annie import PyHnswIndex, AnnIndex def benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10): print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\") # Data data = np.random.rand(n, dim).astype(np.float32) ids = np.arange(n, dtype=np.int64) queries = np.random.rand(q, dim).astype(np.float32) # Index setup index = index_cls(dims=dim) index.add(data, ids) # Warm-up + Timing times = [] for i in range(q): start = time.perf_counter() _ = index.search(queries[i], k=k) times.append((time.perf_counter() - start) * 1000) print(f\" Avg query time: {np.mean(times):.3f} ms\") print(f\" Max query time: {np.max(times):.3f} ms\") print(f\" Min query time: {np.min(times):.3f} ms\") if __name__ == \"__main__\": benchmark(PyHnswIndex, \"HNSW\") benchmark(AnnIndex, \"Brute-Force\")","title":"Example: Benchmarking Script"},{"location":"filtering/#integration-extensibility","text":"Filters are exposed from Rust to Python via PyO3 bindings. New filters can be added by extending src/filters.rs in the Rust code. Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API.","title":"Integration &amp; Extensibility"},{"location":"filtering/#see-also","text":"Example usage: scripts/filter_example.py Unit tests covering filter behavior: tests/test_filters.py Benchmarking script: scripts/compare.py ```","title":"See also"},{"location":"api/ann_index/","text":"AnnIndex \u00b6","title":"AnnIndex"},{"location":"api/ann_index/#annindex","text":"","title":"AnnIndex"},{"location":"api/hnsw_index/","text":"PyHnswIndex \u00b6","title":"PyHnswIndex"},{"location":"api/hnsw_index/#pyhnswindex","text":"","title":"PyHnswIndex"},{"location":"api/threadsafe_index/","text":"ThreadSafeAnnIndex \u00b6","title":"ThreadSafeAnnIndex"},{"location":"api/threadsafe_index/#threadsafeannindex","text":"","title":"ThreadSafeAnnIndex"}]}