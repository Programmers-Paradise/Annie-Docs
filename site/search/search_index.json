{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Annie.io","text":"<p>Blazingly fast Approximate Nearest Neighbors in Rust</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># Stable release from PyPI:\npip install rust-annie\n\n# Install with GPU support (requires CUDA):\npip install rust-annie[gpu]\n\n# Or install from source:\ngit clone https://github.com/Programmers-Paradise/Annie.git\ncd Annie\npip install maturin\nmaturin develop --release\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":""},{"location":"#brute-force-index","title":"Brute-Force Index","text":"<pre><code>import numpy as np\nfrom rust_annie import AnnIndex, Distance\n\n# Create index\nindex = AnnIndex(128, Distance.EUCLIDEAN)\n\n# Add data\ndata = np.random.rand(1000, 128).astype(np.float32)\nids = np.arange(1000, dtype=np.int64)\nindex.add(data, ids)\n\n# Search\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, distances = index.search(query, k=5)\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Multiple Backends:</li> <li>Brute-force (exact) with SIMD acceleration</li> <li>HNSW (approximate) for large-scale datasets</li> <li>Multiple Distance Metrics: Euclidean, Cosine, Manhattan, Chebyshev</li> <li>Batch Queries for efficient processing</li> <li>Thread-safe indexes with concurrent access</li> <li>Zero-copy NumPy integration</li> <li>On-disk Persistence with serialization</li> <li>Filtered Search with custom Python callbacks</li> <li>GPU Acceleration for brute-force calculations</li> <li>Multi-platform support (Linux, Windows, macOS)</li> <li>Automated CI with performance tracking</li> </ul>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li>API Reference - Core classes and methods</li> <li>Examples - Usage examples and tutorials</li> <li>Concurrency - Thread-safe operations</li> <li>Filtering - Custom search filters</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Benchmark Results</li> </ul>"},{"location":"concurrency/","title":"Using <code>ThreadSafeAnnIndex</code> and <code>PyHnswIndex</code> for Concurrent Access","text":"<p>Annie exposes a thread-safe version of its ANN index (<code>AnnIndex</code>) for use in Python. This is useful when you want to perform parallel search or update operations from Python threads. Additionally, the <code>PyHnswIndex</code> class provides a Python interface to the HNSW index, which now includes enhanced data handling capabilities.</p>"},{"location":"concurrency/#key-features","title":"Key Features","text":"<ul> <li>Safe concurrent read access (<code>search</code>, <code>search_batch</code>)</li> <li>Exclusive write access (<code>add</code>, <code>remove</code>)</li> <li>Backed by Rust <code>RwLock</code> and exposed via PyO3</li> <li><code>PyHnswIndex</code> supports mapping internal IDs to user IDs and handling vector data efficiently</li> </ul>"},{"location":"concurrency/#example","title":"Example","text":"<pre><code>from annie import ThreadSafeAnnIndex, Distance\nimport numpy as np\nimport threading\n\n# Create index\nindex = ThreadSafeAnnIndex(128, Distance.Cosine)\n\n# Add vectors\ndata = np.random.rand(1000, 128).astype('float32')\nids = np.arange(1000, dtype=np.int64)\nindex.add(data, ids)\n\n# Run concurrent searches\ndef run_search():\n    query = np.random.rand(128).astype('float32')\n    ids, distances = index.search(query, 10)\n    print(ids)\n\nthreads = [threading.Thread(target=run_search) for _ in range(4)]\n[t.start() for t in threads]\n[t.join() for t in threads]\n\n# Using PyHnswIndex\nfrom rust_annie import PyHnswIndex\n\n# Create HNSW index\nhnsw_index = PyHnswIndex(dims=128)\n\n# Add vectors to HNSW index\nhnsw_index.add(data, ids)\n\n# Search in HNSW index\nquery = np.random.rand(128).astype('float32')\nuser_ids, distances = hnsw_index.search(query, 10)\nprint(user_ids)\n</code></pre>"},{"location":"concurrency/#cicd-pipeline-for-pypi-publishing","title":"CI/CD Pipeline for PyPI Publishing","text":"<p>The CI/CD pipeline for PyPI publishing has been updated to include parallel jobs for building wheels and source distributions across multiple operating systems and Python versions. This involves concurrency considerations that should be documented for users who are integrating or maintaining the pipeline.</p>"},{"location":"concurrency/#pipeline-overview","title":"Pipeline Overview","text":"<p>The pipeline is triggered on pushes and pull requests to the <code>main</code> branch, as well as manually via <code>workflow_dispatch</code>. It includes the following jobs:</p> <ul> <li>Test: Runs on <code>ubuntu-latest</code> and includes steps for checking out the code, setting up Rust, caching dependencies, running tests, and checking code formatting.</li> <li>Build Wheels: Runs in parallel across <code>ubuntu-latest</code>, <code>windows-latest</code>, and <code>macos-latest</code> for Python versions 3.8, 3.9, 3.10, and 3.11. This job builds the wheels using <code>maturin</code> and uploads them as artifacts.</li> <li>Build Source Distribution: Runs on <code>ubuntu-latest</code> and builds the source distribution using <code>maturin</code>, uploading it as an artifact.</li> <li>Publish to TestPyPI: Publishes the built artifacts to TestPyPI if triggered via <code>workflow_dispatch</code> with the appropriate input.</li> <li>Publish to PyPI: Publishes the built artifacts to PyPI if triggered via <code>workflow_dispatch</code> with the appropriate input.</li> </ul>"},{"location":"concurrency/#concurrency-considerations","title":"Concurrency Considerations","text":"<ul> <li>Parallel Builds: The <code>build-wheels</code> job utilizes a matrix strategy to run builds concurrently across different operating systems and Python versions. This reduces the overall build time but requires careful management of dependencies and environment setup to ensure consistency across platforms.</li> <li>Artifact Management: Artifacts from parallel jobs are downloaded and flattened before publishing to ensure all necessary files are available in a single directory structure for the publish steps.</li> <li>Conditional Publishing: Publishing steps are conditionally executed based on manual triggers and input parameters, allowing for flexible deployment strategies.</li> </ul> <p>By understanding these concurrency considerations, users can effectively manage and extend the CI/CD pipeline to suit their specific needs.</p>"},{"location":"concurrency/#annindex-brute-force-nearest-neighbor-search","title":"AnnIndex - Brute-force Nearest Neighbor Search","text":"<p>The <code>AnnIndex</code> class provides efficient brute-force nearest neighbor search with support for multiple distance metrics.</p>"},{"location":"concurrency/#constructor","title":"Constructor","text":""},{"location":"concurrency/#annindexdim-int-metric-distance","title":"<code>AnnIndex(dim: int, metric: Distance)</code>","text":"<p>Creates a new brute-force index.</p> <ul> <li><code>dim</code> (int): Vector dimension</li> <li><code>metric</code> (Distance): Distance metric (<code>EUCLIDEAN</code>, <code>COSINE</code>, <code>MANHATTAN</code>, <code>CHEBYSHEV</code>)</li> </ul>"},{"location":"concurrency/#new_minkowskidim-int-p-float","title":"<code>new_minkowski(dim: int, p: float)</code>","text":"<p>Creates a Minkowski distance index.</p> <ul> <li><code>dim</code> (int): Vector dimension</li> <li><code>p</code> (float): Minkowski exponent (p &gt; 0)</li> </ul>"},{"location":"concurrency/#methods","title":"Methods","text":""},{"location":"concurrency/#adddata-ndarray-ids-ndarray","title":"<code>add(data: ndarray, ids: ndarray)</code>","text":"<p>Add vectors to the index.</p> <ul> <li><code>data</code>: N\u00d7dim array of float32 vectors</li> <li><code>ids</code>: N-dimensional array of int64 IDs</li> </ul>"},{"location":"concurrency/#searchquery-ndarray-k-int-tuplendarray-ndarray","title":"<code>search(query: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]</code>","text":"<p>Search for k nearest neighbors.</p> <ul> <li><code>query</code>: dim-dimensional query vector</li> <li><code>k</code>: Number of neighbors to return</li> <li>Returns: (neighbor IDs, distances)</li> </ul>"},{"location":"concurrency/#search_batchqueries-ndarray-k-int-tuplendarray-ndarray","title":"<code>search_batch(queries: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]</code>","text":"<p>Batch search for multiple queries.</p> <ul> <li><code>queries</code>: M\u00d7dim array of queries</li> <li><code>k</code>: Number of neighbors per query</li> <li>Returns: (M\u00d7k IDs, M\u00d7k distances)</li> </ul>"},{"location":"concurrency/#search_filter_pyquery-ndarray-k-int-filter_fn-callableint-bool-tuplendarray-ndarray","title":"<code>search_filter_py(query: ndarray, k: int, filter_fn: Callable[[int], bool]) -&gt; Tuple[ndarray, ndarray]</code>","text":"<p>Search with ID filtering.</p> <ul> <li><code>query</code>: dim-dimensional query vector</li> <li><code>k</code>: Maximum neighbors to return</li> <li><code>filter_fn</code>: Function that returns True for allowed IDs</li> <li>Returns: (filtered IDs, filtered distances)</li> </ul>"},{"location":"concurrency/#savepath-str","title":"<code>save(path: str)</code>","text":"<p>Save index to disk.</p>"},{"location":"concurrency/#static-loadpath-str-annindex","title":"<code>static load(path: str) -&gt; AnnIndex</code>","text":"<p>Load index from disk.</p>"},{"location":"concurrency/#example_1","title":"Example","text":"<pre><code>import numpy as np\nfrom rust_annie import AnnIndex, Distance\n\n# Create index\nindex = AnnIndex(128, Distance.EUCLIDEAN)\n\n# Add data\ndata = np.random.rand(1000, 128).astype(np.float32)\nids = np.arange(1000, dtype=np.int64)\nindex.add(data, ids)\n\n# Search\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, distances = index.search(query, k=5)\n</code></pre>"},{"location":"concurrency/#pyhnswindex-approximate-nearest-neighbors-with-hnsw","title":"PyHnswIndex - Approximate Nearest Neighbors with HNSW","text":"<p>The <code>PyHnswIndex</code> class provides approximate nearest neighbor search using Hierarchical Navigable Small World (HNSW) graphs.</p>"},{"location":"concurrency/#constructor_1","title":"Constructor","text":""},{"location":"concurrency/#pyhnswindexdims-int","title":"<code>PyHnswIndex(dims: int)</code>","text":"<p>Creates a new HNSW index.</p> <ul> <li><code>dims</code> (int): Vector dimension</li> </ul>"},{"location":"concurrency/#methods_1","title":"Methods","text":""},{"location":"concurrency/#adddata-ndarray-ids-ndarray_1","title":"<code>add(data: ndarray, ids: ndarray)</code>","text":"<p>Add vectors to the index.</p> <ul> <li><code>data</code>: N\u00d7dims array of float32 vectors</li> <li><code>ids</code>: N-dimensional array of int64 IDs</li> </ul>"},{"location":"concurrency/#searchvector-ndarray-k-int-tuplendarray-ndarray","title":"<code>search(vector: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]</code>","text":"<p>Search for k approximate nearest neighbors.</p> <ul> <li><code>vector</code>: dims-dimensional query vector</li> <li><code>k</code>: Number of neighbors to return</li> <li>Returns: (neighbor IDs, distances)</li> </ul>"},{"location":"concurrency/#savepath-str_1","title":"<code>save(path: str)</code>","text":"<p>Save index to disk.</p>"},{"location":"concurrency/#static-loadpath-str-pyhnswindex","title":"<code>static load(path: str) -&gt; PyHnswIndex</code>","text":"<p>Load index from disk (currently not implemented)</p>"},{"location":"concurrency/#example_2","title":"Example","text":"<pre><code>import numpy as np\nfrom rust_annie import PyHnswIndex\n\n# Create index\nindex = PyHnswIndex(dims=128)\n\n# Add data\ndata = np.random.rand(10000, 128).astype(np.float32)\nids = np.arange(10000, dtype=np.int64)\nindex.add(data, ids)\n\n# Search\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, _ = index.search(query, k=10)\n</code></pre>"},{"location":"concurrency/#threadsafeannindex-thread-safe-nearest-neighbor-index","title":"ThreadSafeAnnIndex - Thread-safe Nearest Neighbor Index","text":"<p>The <code>ThreadSafeAnnIndex</code> class provides a thread-safe wrapper around <code>AnnIndex</code> for concurrent access.</p>"},{"location":"concurrency/#constructor_2","title":"Constructor","text":""},{"location":"concurrency/#threadsafeannindexdim-int-metric-distance","title":"<code>ThreadSafeAnnIndex(dim: int, metric: Distance)</code>","text":"<p>Creates a new thread-safe index.</p> <ul> <li><code>dim</code> (int): Vector dimension</li> <li><code>metric</code> (Distance): Distance metric</li> </ul>"},{"location":"concurrency/#methods_2","title":"Methods","text":""},{"location":"concurrency/#adddata-ndarray-ids-ndarray_2","title":"<code>add(data: ndarray, ids: ndarray)</code>","text":"<p>Thread-safe vector addition.</p>"},{"location":"concurrency/#removeids-listint","title":"<code>remove(ids: List[int])</code>","text":"<p>Thread-safe removal by IDs.</p>"},{"location":"concurrency/#searchquery-ndarray-k-int-tuplendarray-ndarray_1","title":"<code>search(query: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]</code>","text":"<p>Thread-safe single query search.</p>"},{"location":"concurrency/#search_batchqueries-ndarray-k-int-tuplendarray-ndarray_1","title":"<code>search_batch(queries: ndarray, k: int) -&gt; Tuple[ndarray, ndarray]</code>","text":"<p>Thread-safe batch search.</p>"},{"location":"concurrency/#savepath-str_2","title":"<code>save(path: str)</code>","text":"<p>Thread-safe save.</p>"},{"location":"concurrency/#static-loadpath-str-threadsafeannindex","title":"<code>static load(path: str) -&gt; ThreadSafeAnnIndex</code>","text":"<p>Thread-safe load.</p>"},{"location":"concurrency/#example_3","title":"Example","text":"<pre><code>import numpy as np\nfrom rust_annie import ThreadSafeAnnIndex, Distance\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Create index\nindex = ThreadSafeAnnIndex(128, Distance.COSINE)\n\n# Add data from multiple threads\nwith ThreadPoolExecutor() as executor:\n    for i in range(4):\n        data = np.random.rand(250, 128).astype(np.float32)\n        ids = np.arange(i*250, (i+1)*250, dtype=np.int64)\n        executor.submit(index.add, data, ids)\n\n# Concurrent searches\nwith ThreadPoolExecutor() as executor:\n    futures = []\n    for _ in range(10):\n        query = np.random.rand(128).astype(np.float32)\n        futures.append(executor.submit(index.search, query, k=5))\n\n    for future in futures:\n        ids, dists = future.result()\n</code></pre>"},{"location":"concurrency/#annie-examples","title":"Annie Examples","text":""},{"location":"concurrency/#basic-usage","title":"Basic Usage","text":"<pre><code>import numpy as np\nfrom rust_annie import AnnIndex, Distance\n\n# Create index\nindex = AnnIndex(128, Distance.EUCLIDEAN)\n\n# Generate and add data\ndata = np.random.rand(1000, 128).astype(np.float32)\nids = np.arange(1000, dtype=np.int64)\nindex.add(data, ids)\n\n# Single query\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, distances = index.search(query, k=5)\n\n# Batch queries\nqueries = np.random.rand(10, 128).astype(np.float32)\nbatch_ids, batch_dists = index.search_batch(queries, k=3)\n</code></pre>"},{"location":"concurrency/#filtered-search","title":"Filtered Search","text":"<pre><code># Create index with sample data\nindex = AnnIndex(3, Distance.EUCLIDEAN)\ndata = np.array([\n    [1.0, 2.0, 3.0],\n    [4.0, 5.0, 6.0],\n    [7.0, 8.0, 9.0]\n], dtype=np.float32)\nids = np.array([10, 20, 30], dtype=np.int64)\nindex.add(data, ids)\n\n# Define filter function\ndef even_ids(id: int) -&gt; bool:\n    return id % 2 == 0\n\n# Filtered search\nquery = np.array([1.0, 2.0, 3.0], dtype=np.float32)\nfiltered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids)\n# Only IDs 10 and 30 will be returned (20 is odd)\n</code></pre>"},{"location":"concurrency/#hnsw-index","title":"HNSW Index","text":"<pre><code>from rust_annie import PyHnswIndex\n\n# Create HNSW index\nindex = PyHnswIndex(dims=128)\n\n# Add large dataset\ndata = np.random.rand(100000, 128).astype(np.float32)\nids = np.arange(100000, dtype=np.int64)\nindex.add(data, ids)\n\n# Fast approximate search\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, _ = index.search(query, k=10)\n</code></pre>"},{"location":"concurrency/#saving-and-loading","title":"Saving and Loading","text":"<pre><code># Create and save index\nindex = AnnIndex(64, Distance.COSINE)\ndata = np.random.rand(500, 64).astype(np.float32)\nids = np.arange(500, dtype=np.int64)\nindex.add(data, ids)\nindex.save(\"my_index\")\n\n# Load index\nloaded_index = AnnIndex.load(\"my_index\")\n</code></pre>"},{"location":"concurrency/#thread-safe-operations","title":"Thread-safe Operations","text":"<pre><code>from rust_annie import ThreadSafeAnnIndex, Distance\nfrom concurrent.futures import ThreadPoolExecutor\n\nindex = ThreadSafeAnnIndex(256, Distance.MANHATTAN)\n\n# Concurrent writes\nwith ThreadPoolExecutor() as executor:\n    for i in range(10):\n        data = np.random.rand(100, 256).astype(np.float32)\n        ids = np.arange(i*100, (i+1)*100, dtype=np.int64)\n        executor.submit(index.add, data, ids)\n\n# Concurrent reads\nwith ThreadPoolExecutor() as executor:\n    futures = []\n    for _ in range(100):\n        query = np.random.rand(256).astype(np.float32)\n        futures.append(executor.submit(index.search, query, k=3))\n\n    results = [f.result() for f in futures]\n</code></pre>"},{"location":"concurrency/#minkowski-distance","title":"Minkowski Distance","text":"<pre><code># Create index with custom distance\nindex = AnnIndex.new_minkowski(dim=64, p=2.5)\ndata = np.random.rand(200, 64).astype(np.float32)\nids = np.arange(200, dtype=np.int64)\nindex.add(data, ids)\n\n# Search with Minkowski distance\nquery = np.random.rand(64).astype(np.float32)\nids, dists = index.search(query, k=5)\n</code></pre>"},{"location":"concurrency/#filtering","title":"Filtering","text":""},{"location":"concurrency/#why-filtering","title":"Why Filtering?","text":"<p>Filters allow you to narrow down search results dynamically based on: - Metadata (e.g., tags, IDs, labels) - Numeric thresholds (e.g., only items above/below a value) - Custom user-defined logic</p> <p>This improves both precision and flexibility of search.</p>"},{"location":"concurrency/#example-python-api","title":"Example: Python API","text":"<pre><code>from rust_annie import AnnIndex\nimport numpy as np\n\n# 1. Create an index with vector dimension 128\nindex = AnnIndex(dimension=128)\n\n# 2. Add data with metadata\nvector0 = np.random.rand(128).astype(np.float32)\nvector1 = np.random.rand(128).astype(np.float32)\n\nindex.add_item(0, vector0, metadata={\"category\": \"A\"})\nindex.add_item(1, vector1, metadata={\"category\": \"B\"})\n\n# 3. Define a filter function (e.g., only include items where category == \"A\")\ndef category_filter(metadata):\n    return metadata.get(\"category\") == \"A\"\n\n# 4. Perform search with the filter applied\nquery_vector = np.random.rand(128).astype(np.float32)\nresults = index.search(query_vector, k=5, filter=category_filter)\n\nprint(\"Filtered search results:\", results)\n</code></pre>"},{"location":"concurrency/#supported-filters","title":"Supported Filters","text":"<p>This library supports applying filters to narrow down ANN search results dynamically.</p> Filter type Example Equals <code>Filter.equals(\"category\", \"A\")</code> Greater than <code>Filter.gt(\"score\", 0.8)</code> Less than <code>Filter.lt(\"price\", 100)</code> Custom predicate <code>Filter.custom(lambda metadata: ...)</code> <p>Filters work on the metadata you provide when adding items to the index.</p>"},{"location":"concurrency/#sorting-behavior","title":"Sorting Behavior","text":"<p>The BruteForceIndex now uses <code>total_cmp</code> for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons.</p>"},{"location":"concurrency/#benchmarking-indices","title":"Benchmarking Indices","text":"<p>The library now includes a benchmarking function to evaluate the performance of different index types, specifically <code>PyHnswIndex</code> and <code>AnnIndex</code>. This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type.</p>"},{"location":"concurrency/#example-benchmarking-script","title":"Example: Benchmarking Script","text":"<pre><code>import numpy as np\nimport time\nfrom rust_annie import PyHnswIndex, AnnIndex\n\ndef benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10):\n    print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\")\n\n    # Data\n    data = np.random.rand(n, dim).astype(np.float32)\n    ids = np.arange(n, dtype=np.int64)\n    queries = np.random.rand(q, dim).astype(np.float32)\n\n    # Index setup\n    index = index_cls(dims=dim)\n    index.add(data, ids)\n\n    # Warm-up + Timing\n    times = []\n    for i in range(q):\n        start = time.perf_counter()\n        _ = index.search(queries[i], k=k)\n        times.append((time.perf_counter() - start) * 1000)\n\n    print(f\"  Avg query time: {np.mean(times):.3f} ms\")\n    print(f\"  Max query time: {np.max(times):.3f} ms\")\n    print(f\"  Min query time: {np.min(times):.3f} ms\")\n\nif __name__ == \"__main__\":\n    benchmark(PyHnswIndex, \"HNSW\")\n    benchmark(AnnIndex, \"Brute-Force\")\n</code></pre>"},{"location":"concurrency/#integration-extensibility","title":"Integration &amp; Extensibility","text":"<ul> <li>Filters are exposed from Rust to Python via PyO3 bindings.</li> <li>New filters can be added by extending <code>src/filters.rs</code> in the Rust code.</li> <li>Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API.</li> </ul>"},{"location":"concurrency/#see-also","title":"See also","text":"<ul> <li>Example usage: <code>scripts/filter_example.py</code></li> <li>Unit tests covering filter behavior: <code>tests/test_filters.py</code></li> <li>Benchmarking script: <code>scripts/compare.py</code></li> </ul>"},{"location":"concurrency/#annie-documentation","title":"Annie Documentation","text":"<p>Blazingly fast Approximate Nearest Neighbors in Rust</p>"},{"location":"concurrency/#installation","title":"Installation","text":"<pre><code>pip install rust_annie\n</code></pre>"},{"location":"concurrency/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import numpy as np\nfrom rust_annie import AnnIndex, Distance\n\n# Create index\nindex = AnnIndex(128, Distance.EUCLIDEAN)\n\n# Add data\ndata = np.random.rand(1000, 128).astype(np.float32)\nids = np.arange(1000, dtype=np.int64)\nindex.add(data, ids)\n\n# Search\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, distances = index.search(query, k=5)\n</code></pre>"},{"location":"concurrency/#key-features_1","title":"Key Features","text":"<ul> <li>Multiple distance metrics</li> <li>CPU/GPU acceleration</li> <li>Thread-safe indexes</li> <li>Filtered search</li> <li>HNSW support</li> </ul>"},{"location":"contributing/","title":"Contributing to Annie Documentation","text":"<p>Thank you for your interest in contributing to Annie's documentation! This guide will help you get started with contributing to our documentation site.</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Getting Started</li> <li>Documentation Structure</li> <li>Setting Up Development Environment</li> <li>Making Changes</li> <li>Writing Guidelines</li> <li>Submitting Changes</li> <li>Review Process</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>Git</li> <li>Text editor or IDE</li> </ul>"},{"location":"contributing/#quick-setup","title":"Quick Setup","text":"<ol> <li>Fork and Clone</li> </ol> <pre><code>git clone https://github.com/YOUR-USERNAME/Annie-Docs.git\ncd Annie-Docs\n</code></pre> <ol> <li>Build Documentation</li> </ol> <pre><code>./build-docs.sh\n</code></pre> <ol> <li>Start Development Server</li> </ol> <pre><code>source venv/bin/activate\nmkdocs serve\n</code></pre> <ol> <li>Open in Browser    Visit <code>http://localhost:8000</code> to see your changes live.</li> </ol>"},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md              # Homepage\n\u251c\u2500\u2500 api/                  # API Reference\n\u2502   \u251c\u2500\u2500 ann_index.md     # AnnIndex class\n\u2502   \u251c\u2500\u2500 hnsw_index.md    # PyHnswIndex class\n\u2502   \u2514\u2500\u2500 threadsafe_index.md\n\u251c\u2500\u2500 examples.md           # Usage examples\n\u251c\u2500\u2500 concurrency.md        # Thread-safety features\n\u2514\u2500\u2500 filtering.md          # Filtered search\n</code></pre>"},{"location":"contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":""},{"location":"contributing/#manual-setup","title":"Manual Setup","text":"<pre><code># Create virtual environment\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Build site\nmkdocs build\n\n# Serve locally with auto-reload\nmkdocs serve --dev-addr=0.0.0.0:8000\n</code></pre>"},{"location":"contributing/#using-scripts","title":"Using Scripts","text":"<pre><code># Build documentation\n./build-docs.sh\n\n# Deploy (build + prepare for hosting)\n./deploy.sh\n</code></pre>"},{"location":"contributing/#making-changes","title":"Making Changes","text":""},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":"<ol> <li>Bug Fixes: Typos, broken links, formatting issues</li> <li>Content Updates: New examples, clarifications, additional details</li> <li>New Documentation: New features, API additions</li> <li>Structure Improvements: Navigation, organization, user experience</li> </ol>"},{"location":"contributing/#workflow","title":"Workflow","text":"<ol> <li>Create a Branch</li> </ol> <pre><code>git checkout -b feature/improve-examples\n</code></pre> <ol> <li> <p>Make Your Changes</p> </li> <li> <p>Edit files in the <code>docs/</code> directory</p> </li> <li>Use Markdown syntax</li> <li> <p>Follow our writing guidelines</p> </li> <li> <p>Test Locally</p> </li> </ol> <pre><code>mkdocs serve\n</code></pre> <p>Visit <code>http://localhost:8000</code> to review changes</p> <ol> <li>Build and Verify <pre><code>mkdocs build\n</code></pre>    Ensure no build errors</li> </ol>"},{"location":"contributing/#writing-guidelines","title":"Writing Guidelines","text":""},{"location":"contributing/#markdown-standards","title":"Markdown Standards","text":"<ul> <li>Use <code>#</code> for main headings, <code>##</code> for sections, <code>###</code> for subsections</li> <li>Use code blocks with language specification:   <pre><code># Good\nimport numpy as np\n</code></pre></li> <li>Use <code>**bold**</code> for emphasis, <code>*italic*</code> for secondary emphasis</li> <li>Use backticks for <code>inline code</code> and class names like <code>AnnIndex</code></li> </ul>"},{"location":"contributing/#code-examples","title":"Code Examples","text":"<ul> <li>Complete Examples: Show full working code</li> <li>Clear Comments: Explain what each section does</li> <li>Realistic Data: Use meaningful variable names and realistic scenarios</li> <li>Error Handling: Include error handling where appropriate</li> </ul> <pre><code># Good example\nimport numpy as np\nfrom rust_annie import AnnIndex, Distance\n\n# Create index for 128-dimensional vectors\nindex = AnnIndex(128, Distance.EUCLIDEAN)\n\n# Add sample data\ndata = np.random.rand(1000, 128).astype(np.float32)\nids = np.arange(1000, dtype=np.int64)\nindex.add(data, ids)\n\n# Search for nearest neighbors\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, distances = index.search(query, k=5)\nprint(f\"Found {len(neighbor_ids)} neighbors\")\n</code></pre>"},{"location":"contributing/#api-documentation","title":"API Documentation","text":"<ul> <li>Class Descriptions: Clear purpose and use cases</li> <li>Parameter Details: Type, description, constraints</li> <li>Return Values: What the method returns</li> <li>Examples: Show typical usage</li> <li>Error Conditions: When methods might fail</li> </ul>"},{"location":"contributing/#writing-style","title":"Writing Style","text":"<ul> <li>Clear and Concise: Get to the point quickly</li> <li>Beginner-Friendly: Explain concepts that might be unfamiliar</li> <li>Consistent Terminology: Use the same terms throughout</li> <li>Active Voice: \"Create an index\" vs \"An index is created\"</li> </ul>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":""},{"location":"contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li>Test Your Changes</li> </ol> <pre><code>mkdocs build  # Check for build errors\nmkdocs serve  # Test locally\n</code></pre> <ol> <li> <p>Check Links</p> </li> <li> <p>Ensure all internal links work</p> </li> <li> <p>Verify external links are accessible</p> </li> <li> <p>Review Content</p> </li> <li>Proofread for typos and grammar</li> <li>Ensure code examples work</li> <li>Check formatting consistency</li> </ol>"},{"location":"contributing/#creating-a-pull-request","title":"Creating a Pull Request","text":"<ol> <li>Commit Your Changes</li> </ol> <pre><code>git add .\ngit commit -m \"docs: improve examples in filtering.md\"\n</code></pre> <ol> <li>Push to Your Fork</li> </ol> <pre><code>git push origin feature/improve-examples\n</code></pre> <ol> <li>Create Pull Request</li> <li>Go to GitHub and create a pull request</li> <li>Use a descriptive title</li> <li>Explain what you changed and why</li> <li>Reference any related issues</li> </ol>"},{"location":"contributing/#pull-request-template","title":"Pull Request Template","text":"<pre><code>## Description\n\nBrief description of changes made.\n\n## Type of Change\n\n- [ ] Bug fix (typo, broken link, etc.)\n- [ ] Content update (new examples, clarifications)\n- [ ] New documentation (new features)\n- [ ] Structure improvement\n\n## Testing\n\n- [ ] Built successfully with `mkdocs build`\n- [ ] Tested locally with `mkdocs serve`\n- [ ] Checked all links work\n- [ ] Verified code examples run\n\n## Screenshots (if applicable)\n\nAdd screenshots of significant visual changes.\n</code></pre>"},{"location":"contributing/#review-process","title":"Review Process","text":""},{"location":"contributing/#what-we-look-for","title":"What We Look For","text":"<ol> <li>Accuracy: Information is correct and up-to-date</li> <li>Clarity: Content is easy to understand</li> <li>Completeness: Examples work and are comprehensive</li> <li>Consistency: Follows existing style and structure</li> <li>Value: Genuinely helpful to users</li> </ol>"},{"location":"contributing/#review-timeline","title":"Review Timeline","text":"<ul> <li>Initial Review: Within 2-3 days</li> <li>Feedback: We'll provide specific suggestions</li> <li>Approval: Once all feedback is addressed</li> </ul>"},{"location":"contributing/#after-approval","title":"After Approval","text":"<ul> <li>Changes are merged to <code>main</code> branch</li> <li>Documentation is automatically deployed</li> <li>Your contribution is credited</li> </ul>"},{"location":"contributing/#issue-labels","title":"Issue Labels","text":"<p>When creating issues, use these labels:</p> <ul> <li><code>documentation</code> - General documentation issues</li> <li><code>bug</code> - Errors in docs (typos, broken links)</li> <li><code>enhancement</code> - Improvements to existing content</li> <li><code>new-content</code> - Requests for new documentation</li> <li><code>good-first-issue</code> - Good for newcomers</li> </ul>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Discussions: Ask questions about contributing</li> <li>Issues: Report bugs or request features</li> </ul> <p>Thank you for helping make Annie's documentation better!</p>"},{"location":"examples/","title":"Annie Examples","text":""},{"location":"examples/#basic-usage","title":"Basic Usage","text":"<pre><code>import numpy as np\nfrom rust_annie import AnnIndex, Distance\n\n# Create index\nindex = AnnIndex(128, Distance.EUCLIDEAN)\n\n# Generate and add data\ndata = np.random.rand(1000, 128).astype(np.float32)\nids = np.arange(1000, dtype=np.int64)\nindex.add(data, ids)\n\n# Single query\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, distances = index.search(query, k=5)\n\n# Batch queries\nqueries = np.random.rand(10, 128).astype(np.float32)\nbatch_ids, batch_dists = index.search_batch(queries, k=3)\n</code></pre>"},{"location":"examples/#filtered-search","title":"Filtered Search","text":"<pre><code># Create index with sample data\nindex = AnnIndex(3, Distance.EUCLIDEAN)\ndata = np.array([\n    [1.0, 2.0, 3.0],\n    [4.0, 5.0, 6.0],\n    [7.0, 8.0, 9.0]\n], dtype=np.float32)\nids = np.array([10, 20, 30], dtype=np.int64)\nindex.add(data, ids)\n\n# Define filter function\ndef even_ids(id: int) -&gt; bool:\n    return id % 2 == 0\n\n# Filtered search\nquery = np.array([1.0, 2.0, 3.0], dtype=np.float32)\nfiltered_ids, filtered_dists = index.search_filter_py(query, k=3, filter_fn=even_ids)\n# Only IDs 10 and 30 will be returned (20 is odd)\n</code></pre>"},{"location":"examples/#hnsw-index","title":"HNSW Index","text":"<pre><code>from rust_annie import PyHnswIndex\n\n# Create HNSW index\nindex = PyHnswIndex(dims=128)\n\n# Add large dataset\ndata = np.random.rand(100000, 128).astype(np.float32)\nids = np.arange(100000, dtype=np.int64)\nindex.add(data, ids)\n\n# Fast approximate search\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, _ = index.search(query, k=10)\n</code></pre>"},{"location":"examples/#saving-and-loading","title":"Saving and Loading","text":"<pre><code># Create and save index\nindex = AnnIndex(64, Distance.COSINE)\ndata = np.random.rand(500, 64).astype(np.float32)\nids = np.arange(500, dtype=np.int64)\nindex.add(data, ids)\nindex.save(\"my_index\")\n\n# Load index\nloaded_index = AnnIndex.load(\"my_index\")\n</code></pre>"},{"location":"examples/#thread-safe-operations","title":"Thread-safe Operations","text":"<pre><code>from rust_annie import ThreadSafeAnnIndex, Distance\nfrom concurrent.futures import ThreadPoolExecutor\n\nindex = ThreadSafeAnnIndex(256, Distance.MANHATTAN)\n\n# Concurrent writes\nwith ThreadPoolExecutor() as executor:\n    for i in range(10):\n        data = np.random.rand(100, 256).astype(np.float32)\n        ids = np.arange(i*100, (i+1)*100, dtype=np.int64)\n        executor.submit(index.add, data, ids)\n\n# Concurrent reads\nwith ThreadPoolExecutor() as executor:\n    futures = []\n    for _ in range(100):\n        query = np.random.rand(256).astype(np.float32)\n        futures.append(executor.submit(index.search, query, k=3))\n\n    results = [f.result() for f in futures]\n</code></pre>"},{"location":"examples/#minkowski-distance","title":"Minkowski Distance","text":"<pre><code># Create index with custom distance\nindex = AnnIndex.new_minkowski(dim=64, p=2.5)\ndata = np.random.rand(200, 64).astype(np.float32)\nids = np.arange(200, dtype=np.int64)\nindex.add(data, ids)\n\n# Search with Minkowski distance\nquery = np.random.rand(64).astype(np.float32)\nids, dists = index.search(query, k=5)\n</code></pre>"},{"location":"examples/#readme","title":"README","text":"<p>A lightning-fast, Rust-powered Approximate Nearest Neighbor library for Python with multiple backends, thread-safety, and GPU acceleration.</p>"},{"location":"examples/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Features </li> <li>Installation </li> <li>Quick Start </li> <li>Examples </li> <li>Brute-Force Index </li> <li>HNSW Index </li> <li>Thread-Safe Index </li> <li>Benchmark Results </li> <li>API Reference </li> <li>Development &amp; CI </li> <li>GPU Acceleration</li> <li>Documentation</li> <li>Contributing </li> <li>License</li> </ol>"},{"location":"examples/#features","title":"Features","text":"<ul> <li>Multiple Backends:</li> <li>Brute-force (exact) with SIMD acceleration</li> <li>HNSW (approximate) for large-scale datasets</li> <li>Multiple Distance Metrics: Euclidean, Cosine, Manhattan, Chebyshev</li> <li>Batch Queries for efficient processing</li> <li>Thread-safe indexes with concurrent access</li> <li>Zero-copy NumPy integration</li> <li>On-disk Persistence with serialization</li> <li>Filtered Search with custom Python callbacks</li> <li>GPU Acceleration for brute-force calculations</li> <li>Multi-platform support (Linux, Windows, macOS)</li> <li>Automated CI with performance tracking</li> </ul>"},{"location":"examples/#installation","title":"Installation","text":"<pre><code># Stable release from PyPI:\npip install rust-annie\n\n# Install with GPU support (requires CUDA):\npip install rust-annie[gpu]\n\n# Or install from source:\ngit clone https://github.com/Programmers-Paradise/Annie.git\ncd Annie\npip install maturin\nmaturin develop --release\n</code></pre>"},{"location":"examples/#quick-start","title":"Quick Start","text":""},{"location":"examples/#brute-force-index","title":"Brute-Force Index","text":"<pre><code>import numpy as np\nfrom rust_annie import AnnIndex, Distance\n\n# Create index\nindex = AnnIndex(128, Distance.EUCLIDEAN)\n\n# Add data\ndata = np.random.rand(1000, 128).astype(np.float32)\nids = np.arange(1000, dtype=np.int64)\nindex.add(data, ids)\n\n# Search\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, distances = index.search(query, k=5)\n</code></pre>"},{"location":"examples/#hnsw-index_1","title":"HNSW Index","text":"<pre><code>from rust_annie import PyHnswIndex\n\nindex = PyHnswIndex(dims=128)\ndata = np.random.rand(10000, 128).astype(np.float32)\nids = np.arange(10000, dtype=np.int64)\nindex.add(data, ids)\n\n# Search\nquery = np.random.rand(128).astype(np.float32)\nneighbor_ids, _ = index.search(query, k=10)\n</code></pre>"},{"location":"examples/#examples","title":"Examples","text":""},{"location":"examples/#brute-force-index_1","title":"Brute-Force Index","text":"<pre><code>from rust_annie import AnnIndex, Distance\nimport numpy as np\n\n# Create index\nidx = AnnIndex(4, Distance.COSINE)\n\n# Add data\ndata = np.random.rand(50, 4).astype(np.float32)\nids = np.arange(50, dtype=np.int64)\nidx.add(data, ids)\n\n# Search\nlabels, dists = idx.search(data[10], k=3)\nprint(labels, dists)\n</code></pre>"},{"location":"examples/#batch-query","title":"Batch Query","text":"<pre><code>from rust_annie import AnnIndex, Distance\nimport numpy as np\n\n# Create index\nidx = AnnIndex(16, Distance.EUCLIDEAN)\n\n# Add data\ndata = np.random.rand(1000, 16).astype(np.float32)\nids = np.arange(1000, dtype=np.int64)\nidx.add(data, ids)\n\n# Batch search\nqueries = data[:32]\nlabels_batch, dists_batch = idx.search_batch(queries, k=10)\nprint(labels_batch.shape)  # (32, 10)\n</code></pre>"},{"location":"examples/#thread-safe-index","title":"Thread-Safe Index","text":"<pre><code>from rust_annie import ThreadSafeAnnIndex, Distance\nimport numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Create thread-safe index\nidx = ThreadSafeAnnIndex(32, Distance.EUCLIDEAN)\n\n# Add data\ndata = np.random.rand(500, 32).astype(np.float32)\nids = np.arange(500, dtype=np.int64)\nidx.add(data, ids)\n\n# Concurrent searches\ndef task(q):\n    return idx.search(q, k=5)\n\nqueries = np.random.rand(100, 32).astype(np.float32)\nwith ThreadPoolExecutor(max_workers=8) as executor:\n    futures = [executor.submit(task, q) for q in queries]\n    for f in futures:\n        print(f.result())\n</code></pre>"},{"location":"examples/#filtered-search_1","title":"Filtered Search","text":"<pre><code>from rust_annie import AnnIndex, Distance\nimport numpy as np\n\n# Create index\nindex = AnnIndex(3, Distance.EUCLIDEAN)\ndata = np.array([\n    [1.0, 2.0, 3.0],\n    [4.0, 5.0, 6.0],\n    [7.0, 8.0, 9.0]\n], dtype=np.float32)\nids = np.array([10, 20, 30], dtype=np.int64)\nindex.add(data, ids)\n\n# Filter function\ndef even_ids(id: int) -&gt; bool:\n    return id % 2 == 0\n\n# Filtered search\nquery = np.array([1.0, 2.0, 3.0], dtype=np.float32)\nfiltered_ids, filtered_dists = index.search_filter_py(\n    query, \n    k=3, \n    filter_fn=even_ids\n)\nprint(filtered_ids)  # [10, 30] (20 is filtered out)\n</code></pre>"},{"location":"examples/#build-and-query-a-brute-force-annindex-in-python-complete-example","title":"Build and Query a Brute-Force AnnIndex in Python (Complete Example)","text":"<p>This section demonstrates a complete, beginner-friendly example of how to build and query a <code>brute-force AnnIndex</code> using Python.</p> <p>Measured on a 6-core CPU:</p> <p>That\u2019s a \\~4\u00d7 speedup vs. NumPy!</p> Operation Dataset Size Time (ms) Speedup vs Python Single Query (Brute) 10,000 \u00d7 64 0.7 4\u00d7 Batch Query (64) 10,000 \u00d7 64 0.23 12\u00d7 HNSW Query 100,000 \u00d7 128 0.05 56\u00d7"},{"location":"examples/#view-full-benchmark-dashboard","title":"View Full Benchmark Dashboard \u2192","text":"<p>You\u2019ll find:</p>"},{"location":"examples/#api-reference","title":"API Reference","text":""},{"location":"examples/#annindex","title":"AnnIndex","text":"<p>Create a brute-force k-NN index.</p> <p>Enum: <code>Distance.EUCLIDEAN</code>, <code>Distance.COSINE</code>, <code>Distance.MANHATTAN</code></p>"},{"location":"examples/#threadsafeannindex","title":"ThreadSafeAnnIndex","text":"<p>Same API as <code>AnnIndex</code>, safe for concurrent use.</p>"},{"location":"examples/#core-classes","title":"Core Classes","text":"Class Description AnnIndex Brute-force exact search PyHnswIndex Approximate HNSW index ThreadSafeAnnIndex Thread-safe wrapper for AnnIndex Distance Distance metrics (Euclidean, Cosine, etc)"},{"location":"examples/#key-methods","title":"Key Methods","text":"Method Description add(data, ids) Add vectors to index search(query, k) Single query search search_batch(queries, k) Batch query search search_filter_py(query, k, filter_fn) Filtered search save(path) Save index to disk load(path) Load index from disk"},{"location":"examples/#development-ci","title":"Development &amp; CI","text":"<p>CI runs on GitHub Actions, building wheels on Linux, Windows, macOS, plus:</p> <ul> <li><code>benchmark.py</code> &amp; <code>batch_benchmark.py</code> &amp; <code>compare_results.py</code></li> </ul> <pre><code># Run tests\ncargo test\npytest tests/\n\n# Run benchmarks\npython scripts/benchmark.py\npython scripts/batch_benchmark.py\n\n# Generate documentation\nmkdocs build\n</code></pre> <p>CI pipeline includes:   - Cross-platform builds (Linux, Windows, macOS)   - Unit tests and integration tests   - Performance benchmarking   - Documentation generation</p>"},{"location":"examples/#benchmark-automation","title":"Benchmark Automation","text":"<p>Benchmarks are tracked over time using:</p>"},{"location":"examples/#gpu-acceleration","title":"GPU Acceleration","text":""},{"location":"examples/#enable-gpu-in-rust","title":"Enable GPU in Rust","text":"<p>Enable CUDA support for brute-force calculations: <pre><code># Install with GPU support\npip install rust-annie[gpu]\n\n# Or build from source with GPU features\nmaturin develop --release --features gpu\n</code></pre></p> <p>Supported operations:   - Batch L2 distance calculations   - High-dimensional similarity search</p> <p>Requirements:   - NVIDIA GPU with CUDA support   - CUDA Toolkit installed</p>"},{"location":"examples/#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please:</p> <p>See ../docs-management/CONTRIBUTING.md for details.</p>"},{"location":"examples/#license","title":"License","text":"<p>This project is licensed under the MIT License. See LICENSE for details.</p>"},{"location":"filtering/","title":"Filtered Search","text":"<pre><code>## ANN Search Filtering\n\nThis document explains how to use the filtering capabilities to improve Approximate Nearest Neighbor (ANN) search.\n\n### Why Filtering?\n\nFilters allow you to narrow down search results dynamically based on:\n- Metadata (e.g., tags, IDs, labels)\n- Numeric thresholds (e.g., only items above/below a value)\n- Custom user-defined logic\n\nThis improves both precision and flexibility of search.\n\n#### Example: Python API\n\n```python\nfrom rust_annie import AnnIndex\nimport numpy as np\n\n# 1. Create an index with vector dimension 128\nindex = AnnIndex(dimension=128)\n\n# 2. Add data with metadata\nvector0 = np.random.rand(128).astype(np.float32)\nvector1 = np.random.rand(128).astype(np.float32)\n\nindex.add_item(0, vector0, metadata={\"category\": \"A\"})\nindex.add_item(1, vector1, metadata={\"category\": \"B\"})\n\n# 3. Define a filter function (e.g., only include items where category == \"A\")\ndef category_filter(metadata):\n    return metadata.get(\"category\") == \"A\"\n\n# 4. Perform search with the filter applied\nquery_vector = np.random.rand(128).astype(np.float32)\nresults = index.search(query_vector, k=5, filter=category_filter)\n\nprint(\"Filtered search results:\", results)\n</code></pre>"},{"location":"filtering/#supported-filters","title":"Supported Filters","text":"<p>This library supports applying filters to narrow down ANN search results dynamically.</p> Filter type Example Equals <code>Filter.equals(\"category\", \"A\")</code> Greater than <code>Filter.gt(\"score\", 0.8)</code> Less than <code>Filter.lt(\"price\", 100)</code> Custom predicate <code>Filter.custom(lambda metadata: ...)</code> <p>Filters work on the metadata you provide when adding items to the index.</p>"},{"location":"filtering/#new-feature-filtered-search-with-custom-python-callbacks","title":"New Feature: Filtered Search with Custom Python Callbacks","text":"<p>The library now supports filtered search using custom Python callbacks, allowing for more complex filtering logic directly in Python.</p>"},{"location":"filtering/#example-filtered-search-with-python-callback","title":"Example: Filtered Search with Python Callback","text":"<pre><code>from rust_annie import AnnIndex, Distance\nimport numpy as np\n\n# Create index\nindex = AnnIndex(3, Distance.EUCLIDEAN)\ndata = np.array([\n    [1.0, 2.0, 3.0],\n    [4.0, 5.0, 6.0],\n    [7.0, 8.0, 9.0]\n], dtype=np.float32)\nids = np.array([10, 20, 30], dtype=np.int64)\nindex.add(data, ids)\n\n# Filter function\ndef even_ids(id: int) -&gt; bool:\n    return id % 2 == 0\n\n# Filtered search\nquery = np.array([1.0, 2.0, 3.0], dtype=np.float32)\nfiltered_ids, filtered_dists = index.search_filter_py(\n    query, \n    k=3, \n    filter_fn=even_ids\n)\nprint(filtered_ids)  # [10, 30] (20 is filtered out)\n</code></pre>"},{"location":"filtering/#sorting-behavior","title":"Sorting Behavior","text":"<p>The BruteForceIndex now uses <code>total_cmp</code> for sorting, which provides NaN-resistant sorting behavior. This change ensures that any NaN values in the data are handled consistently, preventing potential issues with partial comparisons.</p>"},{"location":"filtering/#benchmarking-indices","title":"Benchmarking Indices","text":"<p>The library now includes a benchmarking function to evaluate the performance of different index types, specifically <code>PyHnswIndex</code> and <code>AnnIndex</code>. This function measures the average, maximum, and minimum query times, providing insights into the efficiency of each index type.</p>"},{"location":"filtering/#example-benchmarking-script","title":"Example: Benchmarking Script","text":"<pre><code>import numpy as np\nimport time\nfrom rust_annie import PyHnswIndex, AnnIndex\n\ndef benchmark(index_cls, name, dim=128, n=10_000, q=100, k=10):\n    print(f\"\\nBenchmarking {name} with {n} vectors (dim={dim})...\")\n\n    # Data\n    data = np.random.rand(n, dim).astype(np.float32)\n    ids = np.arange(n, dtype=np.int64)\n    queries = np.random.rand(q, dim).astype(np.float32)\n\n    # Index setup\n    index = index_cls(dims=dim)\n    index.add(data, ids)\n\n    # Warm-up + Timing\n    times = []\n    for i in range(q):\n        start = time.perf_counter()\n        _ = index.search(queries[i], k=k)\n        times.append((time.perf_counter() - start) * 1000)\n\n    print(f\"  Avg query time: {np.mean(times):.3f} ms\")\n    print(f\"  Max query time: {np.max(times):.3f} ms\")\n    print(f\"  Min query time: {np.min(times):.3f} ms\")\n\nif __name__ == \"__main__\":\n    benchmark(PyHnswIndex, \"HNSW\")\n    benchmark(AnnIndex, \"Brute-Force\")\n</code></pre>"},{"location":"filtering/#integration-extensibility","title":"Integration &amp; Extensibility","text":"<ul> <li>Filters are exposed from Rust to Python via PyO3 bindings.</li> <li>New filters can be added by extending <code>src/filters.rs</code> in the Rust code.</li> <li>Filters integrate cleanly with the existing ANN index search logic, so adding or combining filters doesn't require changes in the core search API.</li> </ul>"},{"location":"filtering/#see-also","title":"See also","text":"<ul> <li>Example usage: <code>scripts/filter_example.py</code></li> <li>Unit tests covering filter behavior: <code>tests/test_filters.py</code></li> <li>Benchmarking script: <code>scripts/compare.py</code> ```</li> </ul>"},{"location":"api/ann_index/","title":"AnnIndex","text":""},{"location":"api/hnsw_index/","title":"PyHnswIndex","text":""},{"location":"api/threadsafe_index/","title":"ThreadSafeAnnIndex","text":""}]}